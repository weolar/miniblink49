// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: disk_cache_proto.proto

#ifndef PROTOBUF_disk_5fcache_5fproto_2eproto__INCLUDED
#define PROTOBUF_disk_5fcache_5fproto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

class ShaderVariableProto;
class ShaderAttributeProto;
class ShaderUniformProto;
class ShaderVaryingProto;
class ShaderProto;
class GpuProgramProto;

// ===================================================================

class ShaderVariableProto : public ::google::protobuf::MessageLite {
public:
    ShaderVariableProto();
    virtual ~ShaderVariableProto();

    ShaderVariableProto(const ShaderVariableProto& from);

    inline ShaderVariableProto& operator=(const ShaderVariableProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    static const ShaderVariableProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderVariableProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    void Swap(ShaderVariableProto* other);

    // implements Message ----------------------------------------------

    ShaderVariableProto* New() const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderVariableProto& from);
    void MergeFrom(const ShaderVariableProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint32 type = 1;
    inline bool has_type() const;
    inline void clear_type();
    static const int kTypeFieldNumber = 1;
    inline ::google::protobuf::uint32 type() const;
    inline void set_type(::google::protobuf::uint32 value);

    // optional uint32 precision = 2;
    inline bool has_precision() const;
    inline void clear_precision();
    static const int kPrecisionFieldNumber = 2;
    inline ::google::protobuf::uint32 precision() const;
    inline void set_precision(::google::protobuf::uint32 value);

    // optional string name = 3;
    inline bool has_name() const;
    inline void clear_name();
    static const int kNameFieldNumber = 3;
    inline const ::std::string& name() const;
    inline void set_name(const ::std::string& value);
    inline void set_name(const char* value);
    inline void set_name(const char* value, size_t size);
    inline ::std::string* mutable_name();
    inline ::std::string* release_name();
    inline void set_allocated_name(::std::string* name);

    // optional string mapped_name = 4;
    inline bool has_mapped_name() const;
    inline void clear_mapped_name();
    static const int kMappedNameFieldNumber = 4;
    inline const ::std::string& mapped_name() const;
    inline void set_mapped_name(const ::std::string& value);
    inline void set_mapped_name(const char* value);
    inline void set_mapped_name(const char* value, size_t size);
    inline ::std::string* mutable_mapped_name();
    inline ::std::string* release_mapped_name();
    inline void set_allocated_mapped_name(::std::string* mapped_name);

    // optional uint32 array_size = 5;
    inline bool has_array_size() const;
    inline void clear_array_size();
    static const int kArraySizeFieldNumber = 5;
    inline ::google::protobuf::uint32 array_size() const;
    inline void set_array_size(::google::protobuf::uint32 value);

    // optional bool static_use = 6;
    inline bool has_static_use() const;
    inline void clear_static_use();
    static const int kStaticUseFieldNumber = 6;
    inline bool static_use() const;
    inline void set_static_use(bool value);

    // repeated .ShaderVariableProto fields = 7;
    inline int fields_size() const;
    inline void clear_fields();
    static const int kFieldsFieldNumber = 7;
    inline const ::ShaderVariableProto& fields(int index) const;
    inline ::ShaderVariableProto* mutable_fields(int index);
    inline ::ShaderVariableProto* add_fields();
    inline const ::google::protobuf::RepeatedPtrField<::ShaderVariableProto>&
    fields() const;
    inline ::google::protobuf::RepeatedPtrField<::ShaderVariableProto>*
    mutable_fields();

    // optional string struct_name = 8;
    inline bool has_struct_name() const;
    inline void clear_struct_name();
    static const int kStructNameFieldNumber = 8;
    inline const ::std::string& struct_name() const;
    inline void set_struct_name(const ::std::string& value);
    inline void set_struct_name(const char* value);
    inline void set_struct_name(const char* value, size_t size);
    inline ::std::string* mutable_struct_name();
    inline ::std::string* release_struct_name();
    inline void set_allocated_struct_name(::std::string* struct_name);

    // @@protoc_insertion_point(class_scope:ShaderVariableProto)
private:
    inline void set_has_type();
    inline void clear_has_type();
    inline void set_has_precision();
    inline void clear_has_precision();
    inline void set_has_name();
    inline void clear_has_name();
    inline void set_has_mapped_name();
    inline void clear_has_mapped_name();
    inline void set_has_array_size();
    inline void clear_has_array_size();
    inline void set_has_static_use();
    inline void clear_has_static_use();
    inline void set_has_struct_name();
    inline void clear_has_struct_name();

    ::google::protobuf::uint32 type_;
    ::google::protobuf::uint32 precision_;
    ::std::string* name_;
    ::std::string* mapped_name_;
    ::google::protobuf::uint32 array_size_;
    bool static_use_;
    ::google::protobuf::RepeatedPtrField<::ShaderVariableProto> fields_;
    ::std::string* struct_name_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderVariableProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderAttributeProto : public ::google::protobuf::MessageLite {
public:
    ShaderAttributeProto();
    virtual ~ShaderAttributeProto();

    ShaderAttributeProto(const ShaderAttributeProto& from);

    inline ShaderAttributeProto& operator=(const ShaderAttributeProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    static const ShaderAttributeProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderAttributeProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    void Swap(ShaderAttributeProto* other);

    // implements Message ----------------------------------------------

    ShaderAttributeProto* New() const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderAttributeProto& from);
    void MergeFrom(const ShaderAttributeProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .ShaderVariableProto basic = 1;
    inline bool has_basic() const;
    inline void clear_basic();
    static const int kBasicFieldNumber = 1;
    inline const ::ShaderVariableProto& basic() const;
    inline ::ShaderVariableProto* mutable_basic();
    inline ::ShaderVariableProto* release_basic();
    inline void set_allocated_basic(::ShaderVariableProto* basic);

    // optional int32 location = 2;
    inline bool has_location() const;
    inline void clear_location();
    static const int kLocationFieldNumber = 2;
    inline ::google::protobuf::int32 location() const;
    inline void set_location(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:ShaderAttributeProto)
private:
    inline void set_has_basic();
    inline void clear_has_basic();
    inline void set_has_location();
    inline void clear_has_location();

    ::ShaderVariableProto* basic_;
    ::google::protobuf::int32 location_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderAttributeProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderUniformProto : public ::google::protobuf::MessageLite {
public:
    ShaderUniformProto();
    virtual ~ShaderUniformProto();

    ShaderUniformProto(const ShaderUniformProto& from);

    inline ShaderUniformProto& operator=(const ShaderUniformProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    static const ShaderUniformProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderUniformProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    void Swap(ShaderUniformProto* other);

    // implements Message ----------------------------------------------

    ShaderUniformProto* New() const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderUniformProto& from);
    void MergeFrom(const ShaderUniformProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .ShaderVariableProto basic = 1;
    inline bool has_basic() const;
    inline void clear_basic();
    static const int kBasicFieldNumber = 1;
    inline const ::ShaderVariableProto& basic() const;
    inline ::ShaderVariableProto* mutable_basic();
    inline ::ShaderVariableProto* release_basic();
    inline void set_allocated_basic(::ShaderVariableProto* basic);

    // @@protoc_insertion_point(class_scope:ShaderUniformProto)
private:
    inline void set_has_basic();
    inline void clear_has_basic();

    ::ShaderVariableProto* basic_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderUniformProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderVaryingProto : public ::google::protobuf::MessageLite {
public:
    ShaderVaryingProto();
    virtual ~ShaderVaryingProto();

    ShaderVaryingProto(const ShaderVaryingProto& from);

    inline ShaderVaryingProto& operator=(const ShaderVaryingProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    static const ShaderVaryingProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderVaryingProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    void Swap(ShaderVaryingProto* other);

    // implements Message ----------------------------------------------

    ShaderVaryingProto* New() const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderVaryingProto& from);
    void MergeFrom(const ShaderVaryingProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .ShaderVariableProto basic = 1;
    inline bool has_basic() const;
    inline void clear_basic();
    static const int kBasicFieldNumber = 1;
    inline const ::ShaderVariableProto& basic() const;
    inline ::ShaderVariableProto* mutable_basic();
    inline ::ShaderVariableProto* release_basic();
    inline void set_allocated_basic(::ShaderVariableProto* basic);

    // optional int32 interpolation = 2;
    inline bool has_interpolation() const;
    inline void clear_interpolation();
    static const int kInterpolationFieldNumber = 2;
    inline ::google::protobuf::int32 interpolation() const;
    inline void set_interpolation(::google::protobuf::int32 value);

    // optional bool is_invariant = 3;
    inline bool has_is_invariant() const;
    inline void clear_is_invariant();
    static const int kIsInvariantFieldNumber = 3;
    inline bool is_invariant() const;
    inline void set_is_invariant(bool value);

    // @@protoc_insertion_point(class_scope:ShaderVaryingProto)
private:
    inline void set_has_basic();
    inline void clear_has_basic();
    inline void set_has_interpolation();
    inline void clear_has_interpolation();
    inline void set_has_is_invariant();
    inline void clear_has_is_invariant();

    ::ShaderVariableProto* basic_;
    ::google::protobuf::int32 interpolation_;
    bool is_invariant_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderVaryingProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderProto : public ::google::protobuf::MessageLite {
public:
    ShaderProto();
    virtual ~ShaderProto();

    ShaderProto(const ShaderProto& from);

    inline ShaderProto& operator=(const ShaderProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    static const ShaderProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const ShaderProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    void Swap(ShaderProto* other);

    // implements Message ----------------------------------------------

    ShaderProto* New() const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const ShaderProto& from);
    void MergeFrom(const ShaderProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bytes sha = 1;
    inline bool has_sha() const;
    inline void clear_sha();
    static const int kShaFieldNumber = 1;
    inline const ::std::string& sha() const;
    inline void set_sha(const ::std::string& value);
    inline void set_sha(const char* value);
    inline void set_sha(const void* value, size_t size);
    inline ::std::string* mutable_sha();
    inline ::std::string* release_sha();
    inline void set_allocated_sha(::std::string* sha);

    // repeated .ShaderAttributeProto attribs = 2;
    inline int attribs_size() const;
    inline void clear_attribs();
    static const int kAttribsFieldNumber = 2;
    inline const ::ShaderAttributeProto& attribs(int index) const;
    inline ::ShaderAttributeProto* mutable_attribs(int index);
    inline ::ShaderAttributeProto* add_attribs();
    inline const ::google::protobuf::RepeatedPtrField<::ShaderAttributeProto>&
    attribs() const;
    inline ::google::protobuf::RepeatedPtrField<::ShaderAttributeProto>*
    mutable_attribs();

    // repeated .ShaderUniformProto uniforms = 3;
    inline int uniforms_size() const;
    inline void clear_uniforms();
    static const int kUniformsFieldNumber = 3;
    inline const ::ShaderUniformProto& uniforms(int index) const;
    inline ::ShaderUniformProto* mutable_uniforms(int index);
    inline ::ShaderUniformProto* add_uniforms();
    inline const ::google::protobuf::RepeatedPtrField<::ShaderUniformProto>&
    uniforms() const;
    inline ::google::protobuf::RepeatedPtrField<::ShaderUniformProto>*
    mutable_uniforms();

    // repeated .ShaderVaryingProto varyings = 4;
    inline int varyings_size() const;
    inline void clear_varyings();
    static const int kVaryingsFieldNumber = 4;
    inline const ::ShaderVaryingProto& varyings(int index) const;
    inline ::ShaderVaryingProto* mutable_varyings(int index);
    inline ::ShaderVaryingProto* add_varyings();
    inline const ::google::protobuf::RepeatedPtrField<::ShaderVaryingProto>&
    varyings() const;
    inline ::google::protobuf::RepeatedPtrField<::ShaderVaryingProto>*
    mutable_varyings();

    // @@protoc_insertion_point(class_scope:ShaderProto)
private:
    inline void set_has_sha();
    inline void clear_has_sha();

    ::std::string* sha_;
    ::google::protobuf::RepeatedPtrField<::ShaderAttributeProto> attribs_;
    ::google::protobuf::RepeatedPtrField<::ShaderUniformProto> uniforms_;
    ::google::protobuf::RepeatedPtrField<::ShaderVaryingProto> varyings_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static ShaderProto* default_instance_;
};
// -------------------------------------------------------------------

class GpuProgramProto : public ::google::protobuf::MessageLite {
public:
    GpuProgramProto();
    virtual ~GpuProgramProto();

    GpuProgramProto(const GpuProgramProto& from);

    inline GpuProgramProto& operator=(const GpuProgramProto& from)
    {
        CopyFrom(from);
        return *this;
    }

    static const GpuProgramProto& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    // Returns the internal default instance pointer. This function can
    // return NULL thus should not be used by the user. This is intended
    // for Protobuf internal code. Please use default_instance() declared
    // above instead.
    static inline const GpuProgramProto* internal_default_instance()
    {
        return default_instance_;
    }
#endif

    void Swap(GpuProgramProto* other);

    // implements Message ----------------------------------------------

    GpuProgramProto* New() const;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
    void CopyFrom(const GpuProgramProto& from);
    void MergeFrom(const GpuProgramProto& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    int GetCachedSize() const { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;

public:
    ::std::string GetTypeName() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bytes sha = 1;
    inline bool has_sha() const;
    inline void clear_sha();
    static const int kShaFieldNumber = 1;
    inline const ::std::string& sha() const;
    inline void set_sha(const ::std::string& value);
    inline void set_sha(const char* value);
    inline void set_sha(const void* value, size_t size);
    inline ::std::string* mutable_sha();
    inline ::std::string* release_sha();
    inline void set_allocated_sha(::std::string* sha);

    // optional uint32 format = 2;
    inline bool has_format() const;
    inline void clear_format();
    static const int kFormatFieldNumber = 2;
    inline ::google::protobuf::uint32 format() const;
    inline void set_format(::google::protobuf::uint32 value);

    // optional bytes program = 3;
    inline bool has_program() const;
    inline void clear_program();
    static const int kProgramFieldNumber = 3;
    inline const ::std::string& program() const;
    inline void set_program(const ::std::string& value);
    inline void set_program(const char* value);
    inline void set_program(const void* value, size_t size);
    inline ::std::string* mutable_program();
    inline ::std::string* release_program();
    inline void set_allocated_program(::std::string* program);

    // optional .ShaderProto vertex_shader = 4;
    inline bool has_vertex_shader() const;
    inline void clear_vertex_shader();
    static const int kVertexShaderFieldNumber = 4;
    inline const ::ShaderProto& vertex_shader() const;
    inline ::ShaderProto* mutable_vertex_shader();
    inline ::ShaderProto* release_vertex_shader();
    inline void set_allocated_vertex_shader(::ShaderProto* vertex_shader);

    // optional .ShaderProto fragment_shader = 5;
    inline bool has_fragment_shader() const;
    inline void clear_fragment_shader();
    static const int kFragmentShaderFieldNumber = 5;
    inline const ::ShaderProto& fragment_shader() const;
    inline ::ShaderProto* mutable_fragment_shader();
    inline ::ShaderProto* release_fragment_shader();
    inline void set_allocated_fragment_shader(::ShaderProto* fragment_shader);

    // @@protoc_insertion_point(class_scope:GpuProgramProto)
private:
    inline void set_has_sha();
    inline void clear_has_sha();
    inline void set_has_format();
    inline void clear_has_format();
    inline void set_has_program();
    inline void clear_has_program();
    inline void set_has_vertex_shader();
    inline void clear_has_vertex_shader();
    inline void set_has_fragment_shader();
    inline void clear_has_fragment_shader();

    ::std::string* sha_;
    ::std::string* program_;
    ::ShaderProto* vertex_shader_;
    ::ShaderProto* fragment_shader_;
    ::google::protobuf::uint32 format_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
#else
    friend void protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
#endif
    friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
    friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

    void InitAsDefaultInstance();
    static GpuProgramProto* default_instance_;
};
// ===================================================================

// ===================================================================

// ShaderVariableProto

// optional uint32 type = 1;
inline bool ShaderVariableProto::has_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderVariableProto::set_has_type()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderVariableProto::clear_has_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderVariableProto::clear_type()
{
    type_ = 0u;
    clear_has_type();
}
inline ::google::protobuf::uint32 ShaderVariableProto::type() const
{
    return type_;
}
inline void ShaderVariableProto::set_type(::google::protobuf::uint32 value)
{
    set_has_type();
    type_ = value;
}

// optional uint32 precision = 2;
inline bool ShaderVariableProto::has_precision() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderVariableProto::set_has_precision()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ShaderVariableProto::clear_has_precision()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderVariableProto::clear_precision()
{
    precision_ = 0u;
    clear_has_precision();
}
inline ::google::protobuf::uint32 ShaderVariableProto::precision() const
{
    return precision_;
}
inline void ShaderVariableProto::set_precision(::google::protobuf::uint32 value)
{
    set_has_precision();
    precision_ = value;
}

// optional string name = 3;
inline bool ShaderVariableProto::has_name() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShaderVariableProto::set_has_name()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void ShaderVariableProto::clear_has_name()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void ShaderVariableProto::clear_name()
{
    if (name_ != &::google::protobuf::internal::GetEmptyString()) {
        name_->clear();
    }
    clear_has_name();
}
inline const ::std::string& ShaderVariableProto::name() const
{
    return *name_;
}
inline void ShaderVariableProto::set_name(const ::std::string& value)
{
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyString()) {
        name_ = new ::std::string;
    }
    name_->assign(value);
}
inline void ShaderVariableProto::set_name(const char* value)
{
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyString()) {
        name_ = new ::std::string;
    }
    name_->assign(value);
}
inline void ShaderVariableProto::set_name(const char* value, size_t size)
{
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyString()) {
        name_ = new ::std::string;
    }
    name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShaderVariableProto::mutable_name()
{
    set_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyString()) {
        name_ = new ::std::string;
    }
    return name_;
}
inline ::std::string* ShaderVariableProto::release_name()
{
    clear_has_name();
    if (name_ == &::google::protobuf::internal::GetEmptyString()) {
        return NULL;
    } else {
        ::std::string* temp = name_;
        name_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
        return temp;
    }
}
inline void ShaderVariableProto::set_allocated_name(::std::string* name)
{
    if (name_ != &::google::protobuf::internal::GetEmptyString()) {
        delete name_;
    }
    if (name) {
        set_has_name();
        name_ = name;
    } else {
        clear_has_name();
        name_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
    }
}

// optional string mapped_name = 4;
inline bool ShaderVariableProto::has_mapped_name() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShaderVariableProto::set_has_mapped_name()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void ShaderVariableProto::clear_has_mapped_name()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void ShaderVariableProto::clear_mapped_name()
{
    if (mapped_name_ != &::google::protobuf::internal::GetEmptyString()) {
        mapped_name_->clear();
    }
    clear_has_mapped_name();
}
inline const ::std::string& ShaderVariableProto::mapped_name() const
{
    return *mapped_name_;
}
inline void ShaderVariableProto::set_mapped_name(const ::std::string& value)
{
    set_has_mapped_name();
    if (mapped_name_ == &::google::protobuf::internal::GetEmptyString()) {
        mapped_name_ = new ::std::string;
    }
    mapped_name_->assign(value);
}
inline void ShaderVariableProto::set_mapped_name(const char* value)
{
    set_has_mapped_name();
    if (mapped_name_ == &::google::protobuf::internal::GetEmptyString()) {
        mapped_name_ = new ::std::string;
    }
    mapped_name_->assign(value);
}
inline void ShaderVariableProto::set_mapped_name(const char* value, size_t size)
{
    set_has_mapped_name();
    if (mapped_name_ == &::google::protobuf::internal::GetEmptyString()) {
        mapped_name_ = new ::std::string;
    }
    mapped_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShaderVariableProto::mutable_mapped_name()
{
    set_has_mapped_name();
    if (mapped_name_ == &::google::protobuf::internal::GetEmptyString()) {
        mapped_name_ = new ::std::string;
    }
    return mapped_name_;
}
inline ::std::string* ShaderVariableProto::release_mapped_name()
{
    clear_has_mapped_name();
    if (mapped_name_ == &::google::protobuf::internal::GetEmptyString()) {
        return NULL;
    } else {
        ::std::string* temp = mapped_name_;
        mapped_name_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
        return temp;
    }
}
inline void ShaderVariableProto::set_allocated_mapped_name(::std::string* mapped_name)
{
    if (mapped_name_ != &::google::protobuf::internal::GetEmptyString()) {
        delete mapped_name_;
    }
    if (mapped_name) {
        set_has_mapped_name();
        mapped_name_ = mapped_name;
    } else {
        clear_has_mapped_name();
        mapped_name_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
    }
}

// optional uint32 array_size = 5;
inline bool ShaderVariableProto::has_array_size() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShaderVariableProto::set_has_array_size()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void ShaderVariableProto::clear_has_array_size()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void ShaderVariableProto::clear_array_size()
{
    array_size_ = 0u;
    clear_has_array_size();
}
inline ::google::protobuf::uint32 ShaderVariableProto::array_size() const
{
    return array_size_;
}
inline void ShaderVariableProto::set_array_size(::google::protobuf::uint32 value)
{
    set_has_array_size();
    array_size_ = value;
}

// optional bool static_use = 6;
inline bool ShaderVariableProto::has_static_use() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShaderVariableProto::set_has_static_use()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void ShaderVariableProto::clear_has_static_use()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void ShaderVariableProto::clear_static_use()
{
    static_use_ = false;
    clear_has_static_use();
}
inline bool ShaderVariableProto::static_use() const
{
    return static_use_;
}
inline void ShaderVariableProto::set_static_use(bool value)
{
    set_has_static_use();
    static_use_ = value;
}

// repeated .ShaderVariableProto fields = 7;
inline int ShaderVariableProto::fields_size() const
{
    return fields_.size();
}
inline void ShaderVariableProto::clear_fields()
{
    fields_.Clear();
}
inline const ::ShaderVariableProto& ShaderVariableProto::fields(int index) const
{
    return fields_.Get(index);
}
inline ::ShaderVariableProto* ShaderVariableProto::mutable_fields(int index)
{
    return fields_.Mutable(index);
}
inline ::ShaderVariableProto* ShaderVariableProto::add_fields()
{
    return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::ShaderVariableProto>&
ShaderVariableProto::fields() const
{
    return fields_;
}
inline ::google::protobuf::RepeatedPtrField<::ShaderVariableProto>*
ShaderVariableProto::mutable_fields()
{
    return &fields_;
}

// optional string struct_name = 8;
inline bool ShaderVariableProto::has_struct_name() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ShaderVariableProto::set_has_struct_name()
{
    _has_bits_[0] |= 0x00000080u;
}
inline void ShaderVariableProto::clear_has_struct_name()
{
    _has_bits_[0] &= ~0x00000080u;
}
inline void ShaderVariableProto::clear_struct_name()
{
    if (struct_name_ != &::google::protobuf::internal::GetEmptyString()) {
        struct_name_->clear();
    }
    clear_has_struct_name();
}
inline const ::std::string& ShaderVariableProto::struct_name() const
{
    return *struct_name_;
}
inline void ShaderVariableProto::set_struct_name(const ::std::string& value)
{
    set_has_struct_name();
    if (struct_name_ == &::google::protobuf::internal::GetEmptyString()) {
        struct_name_ = new ::std::string;
    }
    struct_name_->assign(value);
}
inline void ShaderVariableProto::set_struct_name(const char* value)
{
    set_has_struct_name();
    if (struct_name_ == &::google::protobuf::internal::GetEmptyString()) {
        struct_name_ = new ::std::string;
    }
    struct_name_->assign(value);
}
inline void ShaderVariableProto::set_struct_name(const char* value, size_t size)
{
    set_has_struct_name();
    if (struct_name_ == &::google::protobuf::internal::GetEmptyString()) {
        struct_name_ = new ::std::string;
    }
    struct_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShaderVariableProto::mutable_struct_name()
{
    set_has_struct_name();
    if (struct_name_ == &::google::protobuf::internal::GetEmptyString()) {
        struct_name_ = new ::std::string;
    }
    return struct_name_;
}
inline ::std::string* ShaderVariableProto::release_struct_name()
{
    clear_has_struct_name();
    if (struct_name_ == &::google::protobuf::internal::GetEmptyString()) {
        return NULL;
    } else {
        ::std::string* temp = struct_name_;
        struct_name_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
        return temp;
    }
}
inline void ShaderVariableProto::set_allocated_struct_name(::std::string* struct_name)
{
    if (struct_name_ != &::google::protobuf::internal::GetEmptyString()) {
        delete struct_name_;
    }
    if (struct_name) {
        set_has_struct_name();
        struct_name_ = struct_name;
    } else {
        clear_has_struct_name();
        struct_name_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
    }
}

// -------------------------------------------------------------------

// ShaderAttributeProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderAttributeProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderAttributeProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderAttributeProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderAttributeProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderAttributeProto::basic() const
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderAttributeProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL)
        basic_ = new ::ShaderVariableProto;
    return basic_;
}
inline ::ShaderVariableProto* ShaderAttributeProto::release_basic()
{
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
inline void ShaderAttributeProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
}

// optional int32 location = 2;
inline bool ShaderAttributeProto::has_location() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderAttributeProto::set_has_location()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ShaderAttributeProto::clear_has_location()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderAttributeProto::clear_location()
{
    location_ = 0;
    clear_has_location();
}
inline ::google::protobuf::int32 ShaderAttributeProto::location() const
{
    return location_;
}
inline void ShaderAttributeProto::set_location(::google::protobuf::int32 value)
{
    set_has_location();
    location_ = value;
}

// -------------------------------------------------------------------

// ShaderUniformProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderUniformProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderUniformProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderUniformProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderUniformProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderUniformProto::basic() const
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderUniformProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL)
        basic_ = new ::ShaderVariableProto;
    return basic_;
}
inline ::ShaderVariableProto* ShaderUniformProto::release_basic()
{
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
inline void ShaderUniformProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
}

// -------------------------------------------------------------------

// ShaderVaryingProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderVaryingProto::has_basic() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderVaryingProto::set_has_basic()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderVaryingProto::clear_has_basic()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderVaryingProto::clear_basic()
{
    if (basic_ != NULL)
        basic_->::ShaderVariableProto::Clear();
    clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderVaryingProto::basic() const
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
    return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderVaryingProto::mutable_basic()
{
    set_has_basic();
    if (basic_ == NULL)
        basic_ = new ::ShaderVariableProto;
    return basic_;
}
inline ::ShaderVariableProto* ShaderVaryingProto::release_basic()
{
    clear_has_basic();
    ::ShaderVariableProto* temp = basic_;
    basic_ = NULL;
    return temp;
}
inline void ShaderVaryingProto::set_allocated_basic(::ShaderVariableProto* basic)
{
    delete basic_;
    basic_ = basic;
    if (basic) {
        set_has_basic();
    } else {
        clear_has_basic();
    }
}

// optional int32 interpolation = 2;
inline bool ShaderVaryingProto::has_interpolation() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderVaryingProto::set_has_interpolation()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ShaderVaryingProto::clear_has_interpolation()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderVaryingProto::clear_interpolation()
{
    interpolation_ = 0;
    clear_has_interpolation();
}
inline ::google::protobuf::int32 ShaderVaryingProto::interpolation() const
{
    return interpolation_;
}
inline void ShaderVaryingProto::set_interpolation(::google::protobuf::int32 value)
{
    set_has_interpolation();
    interpolation_ = value;
}

// optional bool is_invariant = 3;
inline bool ShaderVaryingProto::has_is_invariant() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShaderVaryingProto::set_has_is_invariant()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void ShaderVaryingProto::clear_has_is_invariant()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void ShaderVaryingProto::clear_is_invariant()
{
    is_invariant_ = false;
    clear_has_is_invariant();
}
inline bool ShaderVaryingProto::is_invariant() const
{
    return is_invariant_;
}
inline void ShaderVaryingProto::set_is_invariant(bool value)
{
    set_has_is_invariant();
    is_invariant_ = value;
}

// -------------------------------------------------------------------

// ShaderProto

// optional bytes sha = 1;
inline bool ShaderProto::has_sha() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderProto::set_has_sha()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ShaderProto::clear_has_sha()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderProto::clear_sha()
{
    if (sha_ != &::google::protobuf::internal::GetEmptyString()) {
        sha_->clear();
    }
    clear_has_sha();
}
inline const ::std::string& ShaderProto::sha() const
{
    return *sha_;
}
inline void ShaderProto::set_sha(const ::std::string& value)
{
    set_has_sha();
    if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
        sha_ = new ::std::string;
    }
    sha_->assign(value);
}
inline void ShaderProto::set_sha(const char* value)
{
    set_has_sha();
    if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
        sha_ = new ::std::string;
    }
    sha_->assign(value);
}
inline void ShaderProto::set_sha(const void* value, size_t size)
{
    set_has_sha();
    if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
        sha_ = new ::std::string;
    }
    sha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShaderProto::mutable_sha()
{
    set_has_sha();
    if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
        sha_ = new ::std::string;
    }
    return sha_;
}
inline ::std::string* ShaderProto::release_sha()
{
    clear_has_sha();
    if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
        return NULL;
    } else {
        ::std::string* temp = sha_;
        sha_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
        return temp;
    }
}
inline void ShaderProto::set_allocated_sha(::std::string* sha)
{
    if (sha_ != &::google::protobuf::internal::GetEmptyString()) {
        delete sha_;
    }
    if (sha) {
        set_has_sha();
        sha_ = sha;
    } else {
        clear_has_sha();
        sha_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
    }
}

// repeated .ShaderAttributeProto attribs = 2;
inline int ShaderProto::attribs_size() const
{
    return attribs_.size();
}
inline void ShaderProto::clear_attribs()
{
    attribs_.Clear();
}
inline const ::ShaderAttributeProto& ShaderProto::attribs(int index) const
{
    return attribs_.Get(index);
}
inline ::ShaderAttributeProto* ShaderProto::mutable_attribs(int index)
{
    return attribs_.Mutable(index);
}
inline ::ShaderAttributeProto* ShaderProto::add_attribs()
{
    return attribs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::ShaderAttributeProto>&
ShaderProto::attribs() const
{
    return attribs_;
}
inline ::google::protobuf::RepeatedPtrField<::ShaderAttributeProto>*
ShaderProto::mutable_attribs()
{
    return &attribs_;
}

// repeated .ShaderUniformProto uniforms = 3;
inline int ShaderProto::uniforms_size() const
{
    return uniforms_.size();
}
inline void ShaderProto::clear_uniforms()
{
    uniforms_.Clear();
}
inline const ::ShaderUniformProto& ShaderProto::uniforms(int index) const
{
    return uniforms_.Get(index);
}
inline ::ShaderUniformProto* ShaderProto::mutable_uniforms(int index)
{
    return uniforms_.Mutable(index);
}
inline ::ShaderUniformProto* ShaderProto::add_uniforms()
{
    return uniforms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::ShaderUniformProto>&
ShaderProto::uniforms() const
{
    return uniforms_;
}
inline ::google::protobuf::RepeatedPtrField<::ShaderUniformProto>*
ShaderProto::mutable_uniforms()
{
    return &uniforms_;
}

// repeated .ShaderVaryingProto varyings = 4;
inline int ShaderProto::varyings_size() const
{
    return varyings_.size();
}
inline void ShaderProto::clear_varyings()
{
    varyings_.Clear();
}
inline const ::ShaderVaryingProto& ShaderProto::varyings(int index) const
{
    return varyings_.Get(index);
}
inline ::ShaderVaryingProto* ShaderProto::mutable_varyings(int index)
{
    return varyings_.Mutable(index);
}
inline ::ShaderVaryingProto* ShaderProto::add_varyings()
{
    return varyings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::ShaderVaryingProto>&
ShaderProto::varyings() const
{
    return varyings_;
}
inline ::google::protobuf::RepeatedPtrField<::ShaderVaryingProto>*
ShaderProto::mutable_varyings()
{
    return &varyings_;
}

// -------------------------------------------------------------------

// GpuProgramProto

// optional bytes sha = 1;
inline bool GpuProgramProto::has_sha() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuProgramProto::set_has_sha()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void GpuProgramProto::clear_has_sha()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void GpuProgramProto::clear_sha()
{
    if (sha_ != &::google::protobuf::internal::GetEmptyString()) {
        sha_->clear();
    }
    clear_has_sha();
}
inline const ::std::string& GpuProgramProto::sha() const
{
    return *sha_;
}
inline void GpuProgramProto::set_sha(const ::std::string& value)
{
    set_has_sha();
    if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
        sha_ = new ::std::string;
    }
    sha_->assign(value);
}
inline void GpuProgramProto::set_sha(const char* value)
{
    set_has_sha();
    if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
        sha_ = new ::std::string;
    }
    sha_->assign(value);
}
inline void GpuProgramProto::set_sha(const void* value, size_t size)
{
    set_has_sha();
    if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
        sha_ = new ::std::string;
    }
    sha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpuProgramProto::mutable_sha()
{
    set_has_sha();
    if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
        sha_ = new ::std::string;
    }
    return sha_;
}
inline ::std::string* GpuProgramProto::release_sha()
{
    clear_has_sha();
    if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
        return NULL;
    } else {
        ::std::string* temp = sha_;
        sha_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
        return temp;
    }
}
inline void GpuProgramProto::set_allocated_sha(::std::string* sha)
{
    if (sha_ != &::google::protobuf::internal::GetEmptyString()) {
        delete sha_;
    }
    if (sha) {
        set_has_sha();
        sha_ = sha;
    } else {
        clear_has_sha();
        sha_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
    }
}

// optional uint32 format = 2;
inline bool GpuProgramProto::has_format() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuProgramProto::set_has_format()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void GpuProgramProto::clear_has_format()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void GpuProgramProto::clear_format()
{
    format_ = 0u;
    clear_has_format();
}
inline ::google::protobuf::uint32 GpuProgramProto::format() const
{
    return format_;
}
inline void GpuProgramProto::set_format(::google::protobuf::uint32 value)
{
    set_has_format();
    format_ = value;
}

// optional bytes program = 3;
inline bool GpuProgramProto::has_program() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuProgramProto::set_has_program()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void GpuProgramProto::clear_has_program()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void GpuProgramProto::clear_program()
{
    if (program_ != &::google::protobuf::internal::GetEmptyString()) {
        program_->clear();
    }
    clear_has_program();
}
inline const ::std::string& GpuProgramProto::program() const
{
    return *program_;
}
inline void GpuProgramProto::set_program(const ::std::string& value)
{
    set_has_program();
    if (program_ == &::google::protobuf::internal::GetEmptyString()) {
        program_ = new ::std::string;
    }
    program_->assign(value);
}
inline void GpuProgramProto::set_program(const char* value)
{
    set_has_program();
    if (program_ == &::google::protobuf::internal::GetEmptyString()) {
        program_ = new ::std::string;
    }
    program_->assign(value);
}
inline void GpuProgramProto::set_program(const void* value, size_t size)
{
    set_has_program();
    if (program_ == &::google::protobuf::internal::GetEmptyString()) {
        program_ = new ::std::string;
    }
    program_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpuProgramProto::mutable_program()
{
    set_has_program();
    if (program_ == &::google::protobuf::internal::GetEmptyString()) {
        program_ = new ::std::string;
    }
    return program_;
}
inline ::std::string* GpuProgramProto::release_program()
{
    clear_has_program();
    if (program_ == &::google::protobuf::internal::GetEmptyString()) {
        return NULL;
    } else {
        ::std::string* temp = program_;
        program_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
        return temp;
    }
}
inline void GpuProgramProto::set_allocated_program(::std::string* program)
{
    if (program_ != &::google::protobuf::internal::GetEmptyString()) {
        delete program_;
    }
    if (program) {
        set_has_program();
        program_ = program;
    } else {
        clear_has_program();
        program_ = const_cast<::std::string*>(&::google::protobuf::internal::GetEmptyString());
    }
}

// optional .ShaderProto vertex_shader = 4;
inline bool GpuProgramProto::has_vertex_shader() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpuProgramProto::set_has_vertex_shader()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void GpuProgramProto::clear_has_vertex_shader()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void GpuProgramProto::clear_vertex_shader()
{
    if (vertex_shader_ != NULL)
        vertex_shader_->::ShaderProto::Clear();
    clear_has_vertex_shader();
}
inline const ::ShaderProto& GpuProgramProto::vertex_shader() const
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return vertex_shader_ != NULL ? *vertex_shader_ : *default_instance().vertex_shader_;
#else
    return vertex_shader_ != NULL ? *vertex_shader_ : *default_instance_->vertex_shader_;
#endif
}
inline ::ShaderProto* GpuProgramProto::mutable_vertex_shader()
{
    set_has_vertex_shader();
    if (vertex_shader_ == NULL)
        vertex_shader_ = new ::ShaderProto;
    return vertex_shader_;
}
inline ::ShaderProto* GpuProgramProto::release_vertex_shader()
{
    clear_has_vertex_shader();
    ::ShaderProto* temp = vertex_shader_;
    vertex_shader_ = NULL;
    return temp;
}
inline void GpuProgramProto::set_allocated_vertex_shader(::ShaderProto* vertex_shader)
{
    delete vertex_shader_;
    vertex_shader_ = vertex_shader;
    if (vertex_shader) {
        set_has_vertex_shader();
    } else {
        clear_has_vertex_shader();
    }
}

// optional .ShaderProto fragment_shader = 5;
inline bool GpuProgramProto::has_fragment_shader() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GpuProgramProto::set_has_fragment_shader()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void GpuProgramProto::clear_has_fragment_shader()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void GpuProgramProto::clear_fragment_shader()
{
    if (fragment_shader_ != NULL)
        fragment_shader_->::ShaderProto::Clear();
    clear_has_fragment_shader();
}
inline const ::ShaderProto& GpuProgramProto::fragment_shader() const
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    return fragment_shader_ != NULL ? *fragment_shader_ : *default_instance().fragment_shader_;
#else
    return fragment_shader_ != NULL ? *fragment_shader_ : *default_instance_->fragment_shader_;
#endif
}
inline ::ShaderProto* GpuProgramProto::mutable_fragment_shader()
{
    set_has_fragment_shader();
    if (fragment_shader_ == NULL)
        fragment_shader_ = new ::ShaderProto;
    return fragment_shader_;
}
inline ::ShaderProto* GpuProgramProto::release_fragment_shader()
{
    clear_has_fragment_shader();
    ::ShaderProto* temp = fragment_shader_;
    fragment_shader_ = NULL;
    return temp;
}
inline void GpuProgramProto::set_allocated_fragment_shader(::ShaderProto* fragment_shader)
{
    delete fragment_shader_;
    fragment_shader_ = fragment_shader;
    if (fragment_shader) {
        set_has_fragment_shader();
    } else {
        clear_has_fragment_shader();
    }
}

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_disk_5fcache_5fproto_2eproto__INCLUDED
