// Copyright (c) 2016 The Chromium Embedded Framework Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the CEF translator tool. If making changes by
// hand only do so within the body of existing method and function
// implementations. See the translator.README.txt file in the tools directory
// for more information.
//

#include "libcef_dll/cpptoc/browser_cpptoc.h"
#include "libcef_dll/cpptoc/drag_data_cpptoc.h"
#include "libcef_dll/ctocpp/render_handler_ctocpp.h"


// VIRTUAL METHODS - Body may be edited by hand.

bool CefRenderHandlerCToCpp::GetRootScreenRect(CefRefPtr<CefBrowser> browser,
    CefRect& rect) {
  cef_render_handler_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_root_screen_rect))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: browser; type: refptr_diff
  DCHECK(browser.get());
  if (!browser.get())
    return false;

  // Execute
  int _retval = _struct->get_root_screen_rect(_struct,
      CefBrowserCppToC::Wrap(browser),
      &rect);

  // Return type: bool
  return _retval?true:false;
}

bool CefRenderHandlerCToCpp::GetViewRect(CefRefPtr<CefBrowser> browser,
    CefRect& rect) {
  cef_render_handler_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_view_rect))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: browser; type: refptr_diff
  DCHECK(browser.get());
  if (!browser.get())
    return false;

  // Execute
  int _retval = _struct->get_view_rect(_struct,
      CefBrowserCppToC::Wrap(browser),
      &rect);

  // Return type: bool
  return _retval?true:false;
}

bool CefRenderHandlerCToCpp::GetScreenPoint(CefRefPtr<CefBrowser> browser,
    int viewX, int viewY, int& screenX, int& screenY) {
  cef_render_handler_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_screen_point))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: browser; type: refptr_diff
  DCHECK(browser.get());
  if (!browser.get())
    return false;

  // Execute
  int _retval = _struct->get_screen_point(_struct,
      CefBrowserCppToC::Wrap(browser),
      viewX,
      viewY,
      &screenX,
      &screenY);

  // Return type: bool
  return _retval?true:false;
}

bool CefRenderHandlerCToCpp::GetScreenInfo(CefRefPtr<CefBrowser> browser,
    CefScreenInfo& screen_info) {
  cef_render_handler_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_screen_info))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: browser; type: refptr_diff
  DCHECK(browser.get());
  if (!browser.get())
    return false;

  // Execute
  int _retval = _struct->get_screen_info(_struct,
      CefBrowserCppToC::Wrap(browser),
      &screen_info);

  // Return type: bool
  return _retval?true:false;
}

void CefRenderHandlerCToCpp::OnPopupShow(CefRefPtr<CefBrowser> browser,
    bool show) {
  cef_render_handler_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, on_popup_show))
    return;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: browser; type: refptr_diff
  DCHECK(browser.get());
  if (!browser.get())
    return;

  // Execute
  _struct->on_popup_show(_struct,
      CefBrowserCppToC::Wrap(browser),
      show);
}

void CefRenderHandlerCToCpp::OnPopupSize(CefRefPtr<CefBrowser> browser,
    const CefRect& rect) {
  cef_render_handler_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, on_popup_size))
    return;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: browser; type: refptr_diff
  DCHECK(browser.get());
  if (!browser.get())
    return;

  // Execute
  _struct->on_popup_size(_struct,
      CefBrowserCppToC::Wrap(browser),
      &rect);
}

void CefRenderHandlerCToCpp::OnPaint(CefRefPtr<CefBrowser> browser,
    PaintElementType type, const RectList& dirtyRects, const void* buffer,
    int width, int height) {
  cef_render_handler_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, on_paint))
    return;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: browser; type: refptr_diff
  DCHECK(browser.get());
  if (!browser.get())
    return;
  // Verify param: buffer; type: simple_byaddr
  DCHECK(buffer);
  if (!buffer)
    return;

  // Translate param: dirtyRects; type: simple_vec_byref_const
  const size_t dirtyRectsCount = dirtyRects.size();
  cef_rect_t* dirtyRectsList = NULL;
  if (dirtyRectsCount > 0) {
    dirtyRectsList = new cef_rect_t[dirtyRectsCount];
    DCHECK(dirtyRectsList);
    if (dirtyRectsList) {
      for (size_t i = 0; i < dirtyRectsCount; ++i) {
        dirtyRectsList[i] = dirtyRects[i];
      }
    }
  }

  // Execute
  _struct->on_paint(_struct,
      CefBrowserCppToC::Wrap(browser),
      type,
      dirtyRectsCount,
      dirtyRectsList,
      buffer,
      width,
      height);

  // Restore param:dirtyRects; type: simple_vec_byref_const
  if (dirtyRectsList)
    delete [] dirtyRectsList;
}

void CefRenderHandlerCToCpp::OnCursorChange(CefRefPtr<CefBrowser> browser,
    CefCursorHandle cursor, CursorType type,
    const CefCursorInfo& custom_cursor_info) {
  cef_render_handler_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, on_cursor_change))
    return;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: browser; type: refptr_diff
  DCHECK(browser.get());
  if (!browser.get())
    return;

  // Execute
  _struct->on_cursor_change(_struct,
      CefBrowserCppToC::Wrap(browser),
      cursor,
      type,
      &custom_cursor_info);
}

bool CefRenderHandlerCToCpp::StartDragging(CefRefPtr<CefBrowser> browser,
    CefRefPtr<CefDragData> drag_data, DragOperationsMask allowed_ops, int x,
    int y) {
  cef_render_handler_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, start_dragging))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: browser; type: refptr_diff
  DCHECK(browser.get());
  if (!browser.get())
    return false;
  // Verify param: drag_data; type: refptr_diff
  DCHECK(drag_data.get());
  if (!drag_data.get())
    return false;

  // Execute
  int _retval = _struct->start_dragging(_struct,
      CefBrowserCppToC::Wrap(browser),
      CefDragDataCppToC::Wrap(drag_data),
      allowed_ops,
      x,
      y);

  // Return type: bool
  return _retval?true:false;
}

void CefRenderHandlerCToCpp::UpdateDragCursor(CefRefPtr<CefBrowser> browser,
    DragOperation operation) {
  cef_render_handler_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, update_drag_cursor))
    return;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: browser; type: refptr_diff
  DCHECK(browser.get());
  if (!browser.get())
    return;

  // Execute
  _struct->update_drag_cursor(_struct,
      CefBrowserCppToC::Wrap(browser),
      operation);
}

void CefRenderHandlerCToCpp::OnScrollOffsetChanged(
    CefRefPtr<CefBrowser> browser, double x, double y) {
  cef_render_handler_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, on_scroll_offset_changed))
    return;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: browser; type: refptr_diff
  DCHECK(browser.get());
  if (!browser.get())
    return;

  // Execute
  _struct->on_scroll_offset_changed(_struct,
      CefBrowserCppToC::Wrap(browser),
      x,
      y);
}


// CONSTRUCTOR - Do not edit by hand.

CefRenderHandlerCToCpp::CefRenderHandlerCToCpp() {
}

template<> cef_render_handler_t* CefCToCpp<CefRenderHandlerCToCpp,
    CefRenderHandler, cef_render_handler_t>::UnwrapDerived(CefWrapperType type,
    CefRenderHandler* c) {
  NOTREACHED() << "Unexpected class type: " << type;
  return NULL;
}

#ifndef NDEBUG
template<> base::AtomicRefCount CefCToCpp<CefRenderHandlerCToCpp,
    CefRenderHandler, cef_render_handler_t>::DebugObjCt = 0;
#endif

template<> CefWrapperType CefCToCpp<CefRenderHandlerCToCpp, CefRenderHandler,
    cef_render_handler_t>::kWrapperType = WT_RENDER_HANDLER;
