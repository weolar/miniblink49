// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#include "config.h"
#include "V8NavigatorPartial.h"

#include "bindings/core/v8/Dictionary.h"
#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/ScriptPromise.h"
#include "bindings/core/v8/ScriptState.h"
#include "bindings/core/v8/V8ArrayBufferView.h"
#include "bindings/core/v8/V8Blob.h"
#include "bindings/core/v8/V8DOMConfiguration.h"
#include "bindings/core/v8/V8FormData.h"
#include "bindings/core/v8/V8HiddenValue.h"
#include "bindings/core/v8/V8Navigator.h"
#include "bindings/core/v8/V8ObjectConstructor.h"
#include "bindings/modules/v8/UnionTypesModules.h"
#include "bindings/modules/v8/V8Bluetooth.h"
#include "bindings/modules/v8/V8CredentialsContainer.h"
#include "bindings/modules/v8/V8DeprecatedStorageQuota.h"
#include "bindings/modules/v8/V8GamepadList.h"
#include "bindings/modules/v8/V8Geolocation.h"
#include "bindings/modules/v8/V8MIDIOptions.h"
#include "bindings/modules/v8/V8MediaDevices.h"
#include "bindings/modules/v8/V8MediaKeySystemConfiguration.h"
#include "bindings/modules/v8/V8MimeTypeArray.h"
#include "bindings/modules/v8/V8NavigatorUserMediaErrorCallback.h"
#include "bindings/modules/v8/V8NavigatorUserMediaSuccessCallback.h"
#include "bindings/modules/v8/V8NetworkInformation.h"
#include "bindings/modules/v8/V8Permissions.h"
#include "bindings/modules/v8/V8PluginArray.h"
#include "bindings/modules/v8/V8Presentation.h"
#include "bindings/modules/v8/V8ServicePortCollection.h"
#include "bindings/modules/v8/V8ServiceWorkerContainer.h"
#include "bindings/modules/v8/V8StorageQuota.h"
#include "core/dom/ContextFeatures.h"
#include "core/dom/Document.h"
#include "core/frame/UseCounter.h"
#include "modules/battery/NavigatorBattery.h"
#include "modules/beacon/NavigatorBeacon.h"
#include "modules/bluetooth/NavigatorBluetooth.h"
#include "modules/credentialmanager/NavigatorCredentials.h"
#include "modules/donottrack/NavigatorDoNotTrack.h"
#include "modules/encryptedmedia/NavigatorRequestMediaKeySystemAccess.h"
#include "modules/gamepad/NavigatorGamepad.h"
#include "modules/geolocation/NavigatorGeolocation.h"
#include "modules/mediastream/NavigatorMediaStream.h"
#include "modules/mediastream/NavigatorUserMedia.h"
#include "modules/navigatorconnect/NavigatorServices.h"
#include "modules/navigatorcontentutils/NavigatorContentUtils.h"
#include "modules/netinfo/NavigatorNetworkInformation.h"
#include "modules/permissions/NavigatorPermissions.h"
#include "modules/plugins/NavigatorPlugins.h"
#include "modules/presentation/NavigatorPresentation.h"
#include "modules/quota/NavigatorStorageQuota.h"
#include "modules/serviceworkers/NavigatorServiceWorker.h"
#include "modules/vibration/NavigatorVibration.h"
#include "modules/vr/NavigatorVRDevice.h"
#include "modules/webmidi/NavigatorWebMIDI.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "platform/TraceEvent.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace blink {

namespace NavigatorPartialV8Internal {

// #ifdef MINIBLINK_NOT_IMPLEMENTED

// static void bluetoothAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     v8::Local<v8::Object> holder = info.Holder();
//     Navigator* impl = V8Navigator::toImpl(holder);
//     RawPtr<Bluetooth> cppValue(NavigatorBluetooth::bluetooth(*impl));
//     if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
//         return;
//     v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
//     if (!v8Value.IsEmpty()) {
//         V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "bluetooth"), v8Value);
//         v8SetReturnValue(info, v8Value);
//     }
// }
// 
// static void bluetoothAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
//     NavigatorPartialV8Internal::bluetoothAttributeGetter(info);
//     TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
// }
// 
// static void credentialsAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     v8::Local<v8::Object> holder = info.Holder();
//     Navigator* impl = V8Navigator::toImpl(holder);
//     RawPtr<CredentialsContainer> cppValue(NavigatorCredentials::credentials(*impl));
//     if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
//         return;
//     v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
//     if (!v8Value.IsEmpty()) {
//         V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "credentials"), v8Value);
//         v8SetReturnValue(info, v8Value);
//     }
// }
// 
// static void credentialsAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
//     NavigatorPartialV8Internal::credentialsAttributeGetter(info);
//     TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
// }
// 
// static void doNotTrackAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     v8::Local<v8::Object> holder = info.Holder();
//     Navigator* impl = V8Navigator::toImpl(holder);
//     v8SetReturnValueStringOrNull(info, NavigatorDoNotTrack::doNotTrack(*impl), info.GetIsolate());
// }
// 
// static void doNotTrackAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
//     NavigatorPartialV8Internal::doNotTrackAttributeGetter(info);
//     TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
// }
// 
static void geolocationAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Navigator* impl = V8Navigator::toImpl(holder);
    RawPtr<Geolocation> cppValue(NavigatorGeolocation::geolocation(*impl));
    if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
        return;
    v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
    if (!v8Value.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "geolocation"), v8Value);
        v8SetReturnValue(info, v8Value);
    }
}

static void geolocationAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NavigatorPartialV8Internal::geolocationAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}
// 
// static void mediaDevicesAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     v8::Local<v8::Object> holder = info.Holder();
//     Navigator* impl = V8Navigator::toImpl(holder);
//     RawPtr<MediaDevices> cppValue(NavigatorUserMedia::mediaDevices(*impl));
//     if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
//         return;
//     v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
//     if (!v8Value.IsEmpty()) {
//         V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "mediaDevices"), v8Value);
//         v8SetReturnValue(info, v8Value);
//     }
// }
// 
// static void mediaDevicesAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
//     NavigatorPartialV8Internal::mediaDevicesAttributeGetter(info);
//     TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
// }
// 
// static void servicesAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     v8::Local<v8::Object> holder = info.Holder();
//     Navigator* impl = V8Navigator::toImpl(holder);
//     ExecutionContext* executionContext = currentExecutionContext(info.GetIsolate());
//     RawPtr<ServicePortCollection> cppValue(NavigatorServices::services(executionContext, *impl));
//     if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
//         return;
//     v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
//     if (!v8Value.IsEmpty()) {
//         V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "services"), v8Value);
//         v8SetReturnValue(info, v8Value);
//     }
// }
// 
// static void servicesAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
//     NavigatorPartialV8Internal::servicesAttributeGetter(info);
//     TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
// }
// 
static void connectionAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Navigator* impl = V8Navigator::toImpl(holder);
    RawPtr<NetworkInformation> cppValue(NavigatorNetworkInformation::connection(*impl));
    if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
        return;
    v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
    if (!v8Value.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "connection"), v8Value);
        v8SetReturnValue(info, v8Value);
    }
}

static void connectionAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::NetInfo);
    NavigatorPartialV8Internal::connectionAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}
// 
// static void permissionsAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     v8::Local<v8::Object> holder = info.Holder();
//     Navigator* impl = V8Navigator::toImpl(holder);
//     RawPtr<Permissions> cppValue(NavigatorPermissions::permissions(*impl));
//     if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
//         return;
//     v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
//     if (!v8Value.IsEmpty()) {
//         V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "permissions"), v8Value);
//         v8SetReturnValue(info, v8Value);
//     }
// }
// 
// static void permissionsAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
//     NavigatorPartialV8Internal::permissionsAttributeGetter(info);
//     TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
// }

// #endif // MINIBLINK_NOT_IMPLEMENTED

static void pluginsAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Navigator* impl = V8Navigator::toImpl(holder);
    RawPtr<DOMPluginArray> cppValue(NavigatorPlugins::plugins(*impl));
    if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
        return;
    v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
    if (!v8Value.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "plugins"), v8Value);
        v8SetReturnValue(info, v8Value);
    }
}

static void pluginsAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NavigatorPartialV8Internal::pluginsAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void mimeTypesAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Navigator* impl = V8Navigator::toImpl(holder);
    RawPtr<DOMMimeTypeArray> cppValue(NavigatorPlugins::mimeTypes(*impl));
    if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
        return;
    v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
    if (!v8Value.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "mimeTypes"), v8Value);
        v8SetReturnValue(info, v8Value);
    }
}

static void mimeTypesAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NavigatorPartialV8Internal::mimeTypesAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

#ifdef MINIBLINK_NOT_IMPLEMENTED

static void presentationAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Navigator* impl = V8Navigator::toImpl(holder);
    RawPtr<Presentation> cppValue(NavigatorPresentation::presentation(*impl));
    if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
        return;
    v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
    if (!v8Value.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "presentation"), v8Value);
        v8SetReturnValue(info, v8Value);
    }
}

static void presentationAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NavigatorPartialV8Internal::presentationAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void webkitTemporaryStorageAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Navigator* impl = V8Navigator::toImpl(holder);
    RawPtr<DeprecatedStorageQuota> cppValue(NavigatorStorageQuota::webkitTemporaryStorage(*impl));
    if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
        return;
    v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
    if (!v8Value.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "webkitTemporaryStorage"), v8Value);
        v8SetReturnValue(info, v8Value);
    }
}

static void webkitTemporaryStorageAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::PrefixedStorageQuota);
    NavigatorPartialV8Internal::webkitTemporaryStorageAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void webkitPersistentStorageAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Navigator* impl = V8Navigator::toImpl(holder);
    RawPtr<DeprecatedStorageQuota> cppValue(NavigatorStorageQuota::webkitPersistentStorage(*impl));
    if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
        return;
    v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
    if (!v8Value.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "webkitPersistentStorage"), v8Value);
        v8SetReturnValue(info, v8Value);
    }
}

static void webkitPersistentStorageAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::PrefixedStorageQuota);
    NavigatorPartialV8Internal::webkitPersistentStorageAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void storageQuotaAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Navigator* impl = V8Navigator::toImpl(holder);
    RawPtr<StorageQuota> cppValue(NavigatorStorageQuota::storageQuota(*impl));
    if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
        return;
    v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
    if (!v8Value.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "storageQuota"), v8Value);
        v8SetReturnValue(info, v8Value);
    }
}

static void storageQuotaAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NavigatorPartialV8Internal::storageQuotaAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void serviceWorkerAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Navigator* impl = V8Navigator::toImpl(holder);
    ExceptionState exceptionState(ExceptionState::GetterContext, "serviceWorker", "Navigator", holder, info.GetIsolate());
    RawPtr<ServiceWorkerContainer> cppValue(NavigatorServiceWorker::serviceWorker(*impl, exceptionState));
    if (UNLIKELY(exceptionState.throwIfNeeded()))
        return;
    if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
        return;
    v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
    if (!v8Value.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "serviceWorker"), v8Value);
        v8SetReturnValue(info, v8Value);
    }
}

static void serviceWorkerAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NavigatorPartialV8Internal::serviceWorkerAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void getBatteryMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = NavigatorBattery::getBattery(scriptState, *impl);
    v8SetReturnValue(info, result.v8Value());
}

static void getBatteryMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NavigatorPartialV8Internal::getBatteryMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void sendBeaconMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "sendBeacon", "Navigator", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    V8StringResource<> url;
    ArrayBufferViewOrBlobOrStringOrFormData data;
    {
        url = info[0];
        if (!url.prepare())
            return;
        if (!info[1]->IsUndefined()) {
            V8ArrayBufferViewOrBlobOrStringOrFormDataOrNull::toImpl(info.GetIsolate(), info[1], data, exceptionState);
            if (exceptionState.throwIfNeeded())
                return;
        } else {
            /* null default value */;
        }
    }
    ExecutionContext* executionContext = currentExecutionContext(info.GetIsolate());
    bool result = NavigatorBeacon::sendBeacon(executionContext, *impl, url, data, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void sendBeaconMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::SendBeacon);
    NavigatorPartialV8Internal::sendBeaconMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void requestMediaKeySystemAccessMethodPromise(const v8::FunctionCallbackInfo<v8::Value>& info, ExceptionState& exceptionState)
{
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    V8StringResource<> keySystem;
    HeapVector<MediaKeySystemConfiguration> supportedConfigurations;
    {
        keySystem = info[0];
        if (!keySystem.prepare(exceptionState))
            return;
        supportedConfigurations = toImplArray<HeapVector<MediaKeySystemConfiguration>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = NavigatorRequestMediaKeySystemAccess::requestMediaKeySystemAccess(scriptState, *impl, keySystem, supportedConfigurations);
    v8SetReturnValue(info, result.v8Value());
}

static void requestMediaKeySystemAccessMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "requestMediaKeySystemAccess", "Navigator", info.Holder(), info.GetIsolate());
    requestMediaKeySystemAccessMethodPromise(info, exceptionState);
    if (exceptionState.hadException())
        v8SetReturnValue(info, exceptionState.reject(ScriptState::current(info.GetIsolate())).v8Value());
}

static void requestMediaKeySystemAccessMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NavigatorPartialV8Internal::requestMediaKeySystemAccessMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void getGamepadsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    v8SetReturnValue(info, NavigatorGamepad::getGamepads(*impl));
}

static void getGamepadsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NavigatorPartialV8Internal::getGamepadsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void webkitGetUserMediaMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "webkitGetUserMedia", "Navigator", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    Dictionary options;
    NavigatorUserMediaSuccessCallback* successCallback;
    NavigatorUserMediaErrorCallback* errorCallback;
    {
        if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
            exceptionState.throwTypeError("parameter 1 ('options') is not an object.");
            exceptionState.throwIfNeeded();
            return;
        }
        options = Dictionary(info[0], info.GetIsolate(), exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        if (info.Length() <= 1 || !info[1]->IsFunction()) {
            exceptionState.throwTypeError("The callback provided as parameter 2 is not a function.");
            exceptionState.throwIfNeeded();
            return;
        }
        successCallback = V8NavigatorUserMediaSuccessCallback::create(v8::Local<v8::Function>::Cast(info[1]), ScriptState::current(info.GetIsolate()));
        if (info.Length() <= 2 || !info[2]->IsFunction()) {
            exceptionState.throwTypeError("The callback provided as parameter 3 is not a function.");
            exceptionState.throwIfNeeded();
            return;
        }
        errorCallback = V8NavigatorUserMediaErrorCallback::create(v8::Local<v8::Function>::Cast(info[2]), ScriptState::current(info.GetIsolate()));
    }
    NavigatorMediaStream::webkitGetUserMedia(*impl, options, successCallback, errorCallback, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void webkitGetUserMediaMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NavigatorPartialV8Internal::webkitGetUserMediaMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

#endif // MINIBLINK_NOT_IMPLEMENTED

static void registerProtocolHandlerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "registerProtocolHandler", "Navigator", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    V8StringResource<> scheme;
    V8StringResource<> url;
    V8StringResource<> title;
    {
        scheme = info[0];
        if (!scheme.prepare())
            return;
        url = info[1];
        if (!url.prepare())
            return;
        title = info[2];
        if (!title.prepare())
            return;
    }
    NavigatorContentUtils::registerProtocolHandler(*impl, scheme, url, title, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void registerProtocolHandlerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NavigatorPartialV8Internal::registerProtocolHandlerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isProtocolHandlerRegisteredMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isProtocolHandlerRegistered", "Navigator", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    V8StringResource<> scheme;
    V8StringResource<> url;
    {
        scheme = info[0];
        if (!scheme.prepare())
            return;
        url = info[1];
        if (!url.prepare())
            return;
    }
    String result = NavigatorContentUtils::isProtocolHandlerRegistered(*impl, scheme, url, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void isProtocolHandlerRegisteredMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NavigatorPartialV8Internal::isProtocolHandlerRegisteredMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void unregisterProtocolHandlerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "unregisterProtocolHandler", "Navigator", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    V8StringResource<> scheme;
    V8StringResource<> url;
    {
        scheme = info[0];
        if (!scheme.prepare())
            return;
        url = info[1];
        if (!url.prepare())
            return;
    }
    NavigatorContentUtils::unregisterProtocolHandler(*impl, scheme, url, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void unregisterProtocolHandlerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NavigatorPartialV8Internal::unregisterProtocolHandlerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void javaEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    v8SetReturnValueBool(info, NavigatorPlugins::javaEnabled(*impl));
}

static void javaEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NavigatorPartialV8Internal::javaEnabledMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

#ifdef MINIBLINK_NOT_IMPLEMENTED

static void vibrate1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "vibrate", "Navigator", info.Holder(), info.GetIsolate());
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    unsigned pattern;
    {
        pattern = toUInt32(info.GetIsolate(), info[0], Clamp, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueBool(info, NavigatorVibration::vibrate(*impl, pattern));
}

static void vibrate2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "vibrate", "Navigator", info.Holder(), info.GetIsolate());
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    Vector<unsigned> pattern;
    {
        pattern = toImplArray<Vector<unsigned>>(info[0], 1, info.GetIsolate(), exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueBool(info, NavigatorVibration::vibrate(*impl, pattern));
}

static void vibrateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "vibrate", "Navigator", info.Holder(), info.GetIsolate());
    switch (std::min(1, info.Length())) {
    case 1:
        if (info[0]->IsArray()) {
            vibrate2Method(info);
            return;
        }
        if (true) {
            vibrate1Method(info);
            return;
        }
        break;
    default:
        break;
    }
    if (info.Length() < 1) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void vibrateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NavigatorPartialV8Internal::vibrateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void getVRDevicesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = NavigatorVRDevice::getVRDevices(scriptState, *impl);
    v8SetReturnValue(info, result.v8Value());
}

static void getVRDevicesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NavigatorPartialV8Internal::getVRDevicesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void requestMIDIAccessMethodPromise(const v8::FunctionCallbackInfo<v8::Value>& info, ExceptionState& exceptionState)
{
    Navigator* impl = V8Navigator::toImpl(info.Holder());
    MIDIOptions options;
    {
        if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
            exceptionState.throwTypeError("parameter 1 ('options') is not an object.");
            return;
        }
        V8MIDIOptions::toImpl(info.GetIsolate(), info[0], options, exceptionState);
        if (exceptionState.hadException())
            return;
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = NavigatorWebMIDI::requestMIDIAccess(scriptState, *impl, options);
    v8SetReturnValue(info, result.v8Value());
}

static void requestMIDIAccessMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "requestMIDIAccess", "Navigator", info.Holder(), info.GetIsolate());
    requestMIDIAccessMethodPromise(info, exceptionState);
    if (exceptionState.hadException())
        v8SetReturnValue(info, exceptionState.reject(ScriptState::current(info.GetIsolate())).v8Value());
}

static void requestMIDIAccessMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::RequestMIDIAccess);
    NavigatorPartialV8Internal::requestMIDIAccessMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

#endif // MINIBLINK_NOT_IMPLEMENTED

} // namespace NavigatorPartialV8Internal

static const V8DOMConfiguration::AccessorConfiguration V8NavigatorAccessors[] = {
#ifdef MINIBLINK_NOT_IMPLEMENTED
    {"doNotTrack", NavigatorPartialV8Internal::doNotTrackAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
#endif // MINIBLINK_NOT_IMPLEMENTED
    {"geolocation", NavigatorPartialV8Internal::geolocationAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"plugins", NavigatorPartialV8Internal::pluginsAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"mimeTypes", NavigatorPartialV8Internal::mimeTypesAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
#ifdef MINIBLINK_NOT_IMPLEMENTED
    {"webkitTemporaryStorage", NavigatorPartialV8Internal::webkitTemporaryStorageAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"webkitPersistentStorage", NavigatorPartialV8Internal::webkitPersistentStorageAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"serviceWorker", NavigatorPartialV8Internal::serviceWorkerAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
#endif // MINIBLINK_NOT_IMPLEMENTED
};

static const V8DOMConfiguration::MethodConfiguration V8NavigatorMethods[] = {
#ifdef MINIBLINK_NOT_IMPLEMENTED
    {"getBattery", NavigatorPartialV8Internal::getBatteryMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"sendBeacon", NavigatorPartialV8Internal::sendBeaconMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"getGamepads", NavigatorPartialV8Internal::getGamepadsMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"webkitGetUserMedia", NavigatorPartialV8Internal::webkitGetUserMediaMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
#endif // MINIBLINK_NOT_IMPLEMENTED
    {"javaEnabled", NavigatorPartialV8Internal::javaEnabledMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
#ifdef MINIBLINK_NOT_IMPLEMENTED
    {"vibrate", NavigatorPartialV8Internal::vibrateMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"requestMIDIAccess", NavigatorPartialV8Internal::requestMIDIAccessMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
#endif // MINIBLINK_NOT_IMPLEMENTED
};

void V8NavigatorPartial::installV8NavigatorTemplate(v8::Local<v8::FunctionTemplate> functionTemplate, v8::Isolate* isolate)
{
    V8Navigator::installV8NavigatorTemplate(functionTemplate, isolate);

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = V8DOMConfiguration::installDOMClassTemplate(isolate, functionTemplate, "Navigator", v8::Local<v8::FunctionTemplate>(), V8Navigator::internalFieldCount,
        0, 0,
        V8NavigatorAccessors, WTF_ARRAY_LENGTH(V8NavigatorAccessors),
        V8NavigatorMethods, WTF_ARRAY_LENGTH(V8NavigatorMethods));
    v8::Local<v8::ObjectTemplate> instanceTemplate = functionTemplate->InstanceTemplate();
    ALLOW_UNUSED_LOCAL(instanceTemplate);
    v8::Local<v8::ObjectTemplate> prototypeTemplate = functionTemplate->PrototypeTemplate();
    ALLOW_UNUSED_LOCAL(prototypeTemplate);

//#ifdef MINIBLINK_NOT_IMPLEMENTED
//     if (RuntimeEnabledFeatures::webBluetoothEnabled()) {
//         static const V8DOMConfiguration::AccessorConfiguration accessorConfiguration =\
//         {"bluetooth", NavigatorPartialV8Internal::bluetoothAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
//         V8DOMConfiguration::installAccessor(isolate, instanceTemplate, prototypeTemplate, functionTemplate, defaultSignature, accessorConfiguration);
//     }
//     if (RuntimeEnabledFeatures::credentialManagerEnabled()) {
//         static const V8DOMConfiguration::AccessorConfiguration accessorConfiguration =\
//         {"credentials", NavigatorPartialV8Internal::credentialsAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
//         V8DOMConfiguration::installAccessor(isolate, instanceTemplate, prototypeTemplate, functionTemplate, defaultSignature, accessorConfiguration);
//     }
//     if (RuntimeEnabledFeatures::enumerateDevicesEnabled()) {
//         static const V8DOMConfiguration::AccessorConfiguration accessorConfiguration =\
//         {"mediaDevices", NavigatorPartialV8Internal::mediaDevicesAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
//         V8DOMConfiguration::installAccessor(isolate, instanceTemplate, prototypeTemplate, functionTemplate, defaultSignature, accessorConfiguration);
//     }
//     if (RuntimeEnabledFeatures::navigatorConnectEnabled()) {
//         static const V8DOMConfiguration::AccessorConfiguration accessorConfiguration =\
//         {"services", NavigatorPartialV8Internal::servicesAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
//         V8DOMConfiguration::installAccessor(isolate, instanceTemplate, prototypeTemplate, functionTemplate, defaultSignature, accessorConfiguration);
//     }
    if (RuntimeEnabledFeatures::networkInformationEnabled()) {
        static const V8DOMConfiguration::AccessorConfiguration accessorConfiguration =\
        {"connection", NavigatorPartialV8Internal::connectionAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
        V8DOMConfiguration::installAccessor(isolate, instanceTemplate, prototypeTemplate, functionTemplate, defaultSignature, accessorConfiguration);
    }
//     if (RuntimeEnabledFeatures::permissionsEnabled()) {
//         static const V8DOMConfiguration::AccessorConfiguration accessorConfiguration =\
//         {"permissions", NavigatorPartialV8Internal::permissionsAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
//         V8DOMConfiguration::installAccessor(isolate, instanceTemplate, prototypeTemplate, functionTemplate, defaultSignature, accessorConfiguration);
//     }
//     if (RuntimeEnabledFeatures::presentationEnabled()) {
//         static const V8DOMConfiguration::AccessorConfiguration accessorConfiguration =\
//         {"presentation", NavigatorPartialV8Internal::presentationAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
//         V8DOMConfiguration::installAccessor(isolate, instanceTemplate, prototypeTemplate, functionTemplate, defaultSignature, accessorConfiguration);
//     }
//     if (RuntimeEnabledFeatures::quotaPromiseEnabled()) {
//         static const V8DOMConfiguration::AccessorConfiguration accessorConfiguration =\
//         {"storageQuota", NavigatorPartialV8Internal::storageQuotaAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
//         V8DOMConfiguration::installAccessor(isolate, instanceTemplate, prototypeTemplate, functionTemplate, defaultSignature, accessorConfiguration);
//     }
//     if (RuntimeEnabledFeatures::encryptedMediaEnabled()) {
//         const V8DOMConfiguration::MethodConfiguration requestMediaKeySystemAccessMethodConfiguration = {
//             "requestMediaKeySystemAccess", NavigatorPartialV8Internal::requestMediaKeySystemAccessMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts,
//         };
//         V8DOMConfiguration::installMethod(isolate, prototypeTemplate, defaultSignature, v8::None, requestMediaKeySystemAccessMethodConfiguration);
//     }
// #endif // MINIBLINK_NOT_IMPLEMENTED

    if (RuntimeEnabledFeatures::navigatorContentUtilsEnabled()) {
        const V8DOMConfiguration::MethodConfiguration registerProtocolHandlerMethodConfiguration = {
            "registerProtocolHandler", NavigatorPartialV8Internal::registerProtocolHandlerMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts,
        };
        V8DOMConfiguration::installMethod(isolate, prototypeTemplate, defaultSignature, v8::None, registerProtocolHandlerMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::customSchemeHandlerEnabled()) {
        const V8DOMConfiguration::MethodConfiguration isProtocolHandlerRegisteredMethodConfiguration = {
            "isProtocolHandlerRegistered", NavigatorPartialV8Internal::isProtocolHandlerRegisteredMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts,
        };
        V8DOMConfiguration::installMethod(isolate, prototypeTemplate, defaultSignature, v8::None, isProtocolHandlerRegisteredMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::navigatorContentUtilsEnabled()) {
        const V8DOMConfiguration::MethodConfiguration unregisterProtocolHandlerMethodConfiguration = {
            "unregisterProtocolHandler", NavigatorPartialV8Internal::unregisterProtocolHandlerMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts,
        };
        V8DOMConfiguration::installMethod(isolate, prototypeTemplate, defaultSignature, v8::None, unregisterProtocolHandlerMethodConfiguration);
    }

#ifdef MINIBLINK_NOT_IMPLEMENTED
    if (RuntimeEnabledFeatures::webVREnabled()) {
        const V8DOMConfiguration::MethodConfiguration getVRDevicesMethodConfiguration = {
            "getVRDevices", NavigatorPartialV8Internal::getVRDevicesMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts,
        };
        V8DOMConfiguration::installMethod(isolate, prototypeTemplate, defaultSignature, v8::None, getVRDevicesMethodConfiguration);
    }
#endif // MINIBLINK_NOT_IMPLEMENTED
}

void V8NavigatorPartial::preparePrototypeObject(v8::Isolate* isolate, v8::Local<v8::Object> prototypeObject, v8::Local<v8::FunctionTemplate> interfaceTemplate)
{
    V8Navigator::preparePrototypeObject(isolate, prototypeObject, interfaceTemplate);
}

void V8NavigatorPartial::initialize()
{
    // Should be invoked from initModules.
    V8Navigator::updateWrapperTypeInfo(
        &V8NavigatorPartial::installV8NavigatorTemplate,
        &V8NavigatorPartial::preparePrototypeObject);
}

} // namespace blink
