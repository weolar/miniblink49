// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#include "config.h"
#include "V8CanvasRenderingContext2D.h"

#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/V8DOMConfiguration.h"
#include "bindings/core/v8/V8Element.h"
#include "bindings/core/v8/V8GCController.h"
#include "bindings/core/v8/V8HTMLCanvasElement.h"
#include "bindings/core/v8/V8HTMLImageElement.h"
#include "bindings/core/v8/V8HTMLVideoElement.h"
#include "bindings/core/v8/V8ImageBitmap.h"
#include "bindings/core/v8/V8ImageData.h"
#include "bindings/core/v8/V8ObjectConstructor.h"
#include "bindings/core/v8/V8SVGMatrix.h"
#include "bindings/core/v8/V8TextMetrics.h"
#include "bindings/modules/v8/UnionTypesModules.h"
#include "bindings/modules/v8/V8Canvas2DContextAttributes.h"
#include "bindings/modules/v8/V8CanvasGradient.h"
#include "bindings/modules/v8/V8CanvasPattern.h"
#include "bindings/modules/v8/V8HitRegionOptions.h"
#include "bindings/modules/v8/V8Path2D.h"
#include "core/dom/ContextFeatures.h"
#include "core/dom/Document.h"
#include "core/dom/Element.h"
#include "core/frame/UseCounter.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "platform/TraceEvent.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace blink {

// Suppress warning: global constructors, because struct WrapperTypeInfo is trivial
// and does not depend on another global objects.
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif
const WrapperTypeInfo V8CanvasRenderingContext2D::wrapperTypeInfo = { gin::kEmbedderBlink, V8CanvasRenderingContext2D::domTemplate, V8CanvasRenderingContext2D::refObject, V8CanvasRenderingContext2D::derefObject, V8CanvasRenderingContext2D::trace, 0, V8CanvasRenderingContext2D::visitDOMWrapper, V8CanvasRenderingContext2D::preparePrototypeObject, V8CanvasRenderingContext2D::installConditionallyEnabledProperties, "CanvasRenderingContext2D", 0, WrapperTypeInfo::WrapperTypeObjectPrototype, WrapperTypeInfo::ObjectClassId, WrapperTypeInfo::NotInheritFromEventTarget, WrapperTypeInfo::Dependent, WrapperTypeInfo::WillBeGarbageCollectedObject };
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic pop
#endif

// This static member must be declared by DEFINE_WRAPPERTYPEINFO in CanvasRenderingContext2D.h.
// For details, see the comment of DEFINE_WRAPPERTYPEINFO in
// bindings/core/v8/ScriptWrappable.h.
const WrapperTypeInfo& CanvasRenderingContext2D::s_wrapperTypeInfo = V8CanvasRenderingContext2D::wrapperTypeInfo;

namespace CanvasRenderingContext2DV8Internal {

static void canvasAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->canvas()), impl);
}

static void canvasAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::canvasAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void currentTransformAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->currentTransform()), impl);
}

static void currentTransformAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::currentTransformAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void currentTransformAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "currentTransform", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    SVGMatrixTearOff* cppValue = V8SVGMatrix::toImplWithTypeCheck(info.GetIsolate(), v8Value);
    if (!cppValue) {
        exceptionState.throwTypeError("The provided value is not of type 'SVGMatrix'.");
        exceptionState.throwIfNeeded();
        return;
    }
    impl->setCurrentTransform(WTF::getPtr(cppValue));
}

static void currentTransformAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::currentTransformAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void globalAlphaAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValue(info, impl->globalAlpha());
}

static void globalAlphaAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::globalAlphaAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void globalAlphaAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "globalAlpha", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    float cppValue = toFloat(info.GetIsolate(), v8Value, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setGlobalAlpha(cppValue);
}

static void globalAlphaAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::globalAlphaAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void globalCompositeOperationAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueString(info, impl->globalCompositeOperation(), info.GetIsolate());
}

static void globalCompositeOperationAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::globalCompositeOperationAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void globalCompositeOperationAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    V8StringResource<TreatNullAsNullString> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setGlobalCompositeOperation(cppValue);
}

static void globalCompositeOperationAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::globalCompositeOperationAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void filterAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueString(info, impl->filter(), info.GetIsolate());
}

static void filterAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::filterAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void filterAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    V8StringResource<> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setFilter(cppValue);
}

static void filterAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::filterAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void webkitImageSmoothingEnabledAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueBool(info, impl->imageSmoothingEnabled());
}

static void webkitImageSmoothingEnabledAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    UseCounter::countDeprecationIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::PrefixedImageSmoothingEnabled);
    CanvasRenderingContext2DV8Internal::webkitImageSmoothingEnabledAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void webkitImageSmoothingEnabledAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "webkitImageSmoothingEnabled", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    bool cppValue = toBoolean(info.GetIsolate(), v8Value, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setImageSmoothingEnabled(cppValue);
}

static void webkitImageSmoothingEnabledAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    UseCounter::countDeprecationIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::PrefixedImageSmoothingEnabled);
    CanvasRenderingContext2DV8Internal::webkitImageSmoothingEnabledAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void imageSmoothingEnabledAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueBool(info, impl->imageSmoothingEnabled());
}

static void imageSmoothingEnabledAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::UnprefixedImageSmoothingEnabled);
    CanvasRenderingContext2DV8Internal::imageSmoothingEnabledAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void imageSmoothingEnabledAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "imageSmoothingEnabled", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    bool cppValue = toBoolean(info.GetIsolate(), v8Value, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setImageSmoothingEnabled(cppValue);
}

static void imageSmoothingEnabledAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::UnprefixedImageSmoothingEnabled);
    CanvasRenderingContext2DV8Internal::imageSmoothingEnabledAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void strokeStyleAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    StringOrCanvasGradientOrCanvasPattern result;
    impl->strokeStyle(result);
    v8SetReturnValue(info, result);
}

static void strokeStyleAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::strokeStyleAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void strokeStyleAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "strokeStyle", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    StringOrCanvasGradientOrCanvasPattern cppValue;
    V8StringOrCanvasGradientOrCanvasPattern::toImpl(info.GetIsolate(), v8Value, cppValue, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setStrokeStyle(cppValue);
}

static void strokeStyleAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::strokeStyleAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void fillStyleAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    StringOrCanvasGradientOrCanvasPattern result;
    impl->fillStyle(result);
    v8SetReturnValue(info, result);
}

static void fillStyleAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::fillStyleAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void fillStyleAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "fillStyle", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    StringOrCanvasGradientOrCanvasPattern cppValue;
    V8StringOrCanvasGradientOrCanvasPattern::toImpl(info.GetIsolate(), v8Value, cppValue, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setFillStyle(cppValue);
}

static void fillStyleAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::fillStyleAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shadowOffsetXAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValue(info, impl->shadowOffsetX());
}

static void shadowOffsetXAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::shadowOffsetXAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shadowOffsetXAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "shadowOffsetX", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    float cppValue = toFloat(info.GetIsolate(), v8Value, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setShadowOffsetX(cppValue);
}

static void shadowOffsetXAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::shadowOffsetXAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shadowOffsetYAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValue(info, impl->shadowOffsetY());
}

static void shadowOffsetYAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::shadowOffsetYAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shadowOffsetYAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "shadowOffsetY", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    float cppValue = toFloat(info.GetIsolate(), v8Value, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setShadowOffsetY(cppValue);
}

static void shadowOffsetYAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::shadowOffsetYAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shadowBlurAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValue(info, impl->shadowBlur());
}

static void shadowBlurAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::shadowBlurAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shadowBlurAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "shadowBlur", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    float cppValue = toFloat(info.GetIsolate(), v8Value, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setShadowBlur(cppValue);
}

static void shadowBlurAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::shadowBlurAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shadowColorAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueString(info, impl->shadowColor(), info.GetIsolate());
}

static void shadowColorAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::shadowColorAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shadowColorAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    V8StringResource<TreatNullAsNullString> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setShadowColor(cppValue);
}

static void shadowColorAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::shadowColorAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lineWidthAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValue(info, impl->lineWidth());
}

static void lineWidthAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::lineWidthAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lineWidthAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "lineWidth", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    float cppValue = toFloat(info.GetIsolate(), v8Value, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setLineWidth(cppValue);
}

static void lineWidthAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::lineWidthAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lineCapAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueString(info, impl->lineCap(), info.GetIsolate());
}

static void lineCapAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::lineCapAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lineCapAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    V8StringResource<TreatNullAsNullString> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setLineCap(cppValue);
}

static void lineCapAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::lineCapAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lineJoinAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueString(info, impl->lineJoin(), info.GetIsolate());
}

static void lineJoinAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::lineJoinAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lineJoinAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    V8StringResource<TreatNullAsNullString> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setLineJoin(cppValue);
}

static void lineJoinAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::lineJoinAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void miterLimitAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValue(info, impl->miterLimit());
}

static void miterLimitAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::miterLimitAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void miterLimitAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "miterLimit", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    float cppValue = toFloat(info.GetIsolate(), v8Value, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setMiterLimit(cppValue);
}

static void miterLimitAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::miterLimitAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lineDashOffsetAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValue(info, impl->lineDashOffset());
}

static void lineDashOffsetAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::lineDashOffsetAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lineDashOffsetAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "lineDashOffset", "CanvasRenderingContext2D", holder, info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    float cppValue = toFloat(info.GetIsolate(), v8Value, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setLineDashOffset(cppValue);
}

static void lineDashOffsetAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::lineDashOffsetAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void fontAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueString(info, impl->font(), info.GetIsolate());
}

static void fontAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::fontAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void fontAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    V8StringResource<> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setFont(cppValue);
}

static void fontAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::fontAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void textAlignAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueString(info, impl->textAlign(), info.GetIsolate());
}

static void textAlignAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::textAlignAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void textAlignAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    V8StringResource<> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setTextAlign(cppValue);
}

static void textAlignAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::textAlignAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void textBaselineAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueString(info, impl->textBaseline(), info.GetIsolate());
}

static void textBaselineAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::textBaselineAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void textBaselineAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    V8StringResource<> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setTextBaseline(cppValue);
}

static void textBaselineAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::textBaselineAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void directionAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    v8SetReturnValueString(info, impl->direction(), info.GetIsolate());
}

static void directionAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    CanvasRenderingContext2DV8Internal::directionAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void directionAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(holder);
    V8StringResource<> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setDirection(cppValue);
}

static void directionAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CanvasRenderingContext2DV8Internal::directionAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void saveMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    impl->save();
}

static void saveMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::saveMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void restoreMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    impl->restore();
}

static void restoreMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::restoreMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void scaleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scale", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->scale(x, y);
}

static void scaleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::scaleMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void rotateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "rotate", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float angle;
    {
        angle = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->rotate(angle);
}

static void rotateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::rotateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void translateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "translate", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->translate(x, y);
}

static void translateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::translateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void transformMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "transform", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 6)) {
        setMinimumArityTypeError(exceptionState, 6, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float a;
    float b;
    float c;
    float d;
    float e;
    float f;
    {
        a = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        b = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        c = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        d = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        e = toFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        f = toFloat(info.GetIsolate(), info[5], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->transform(a, b, c, d, e, f);
}

static void transformMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::transformMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setTransformMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setTransform", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 6)) {
        setMinimumArityTypeError(exceptionState, 6, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float a;
    float b;
    float c;
    float d;
    float e;
    float f;
    {
        a = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        b = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        c = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        d = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        e = toFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        f = toFloat(info.GetIsolate(), info[5], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setTransform(a, b, c, d, e, f);
}

static void setTransformMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::setTransformMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void resetTransformMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    impl->resetTransform();
}

static void resetTransformMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::resetTransformMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void createLinearGradientMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createLinearGradient", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        setMinimumArityTypeError(exceptionState, 4, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x0;
    float y0;
    float x1;
    float y1;
    {
        x0 = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y0 = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        x1 = toRestrictedFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y1 = toRestrictedFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValue(info, impl->createLinearGradient(x0, y0, x1, y1));
}

static void createLinearGradientMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::createLinearGradientMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void createRadialGradientMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createRadialGradient", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 6)) {
        setMinimumArityTypeError(exceptionState, 6, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x0;
    float y0;
    float r0;
    float x1;
    float y1;
    float r1;
    {
        x0 = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y0 = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        r0 = toRestrictedFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        x1 = toRestrictedFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y1 = toRestrictedFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        r1 = toRestrictedFloat(info.GetIsolate(), info[5], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    RawPtr<CanvasGradient> result = impl->createRadialGradient(x0, y0, r0, x1, y1, r1, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void createRadialGradientMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::createRadialGradientMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void createPatternMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createPattern", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrImageBitmap image;
    V8StringResource<TreatNullAsNullString> repetitionType;
    {
        V8HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrImageBitmap::toImpl(info.GetIsolate(), info[0], image, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        repetitionType = info[1];
        if (!repetitionType.prepare())
            return;
    }
    RawPtr<CanvasPattern> result = impl->createPattern(image, repetitionType, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void createPatternMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::createPatternMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void clearRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "clearRect", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        setMinimumArityTypeError(exceptionState, 4, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    float width;
    float height;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        width = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        height = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->clearRect(x, y, width, height);
}

static void clearRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::clearRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void fillRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "fillRect", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        setMinimumArityTypeError(exceptionState, 4, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    float width;
    float height;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        width = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        height = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->fillRect(x, y, width, height);
}

static void fillRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::fillRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void strokeRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "strokeRect", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        setMinimumArityTypeError(exceptionState, 4, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    float width;
    float height;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        width = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        height = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->strokeRect(x, y, width, height);
}

static void strokeRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::strokeRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void beginPathMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    impl->beginPath();
}

static void beginPathMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::beginPathMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void fill1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "fill", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    V8StringResource<> winding;
    {
        if (UNLIKELY(info.Length() <= 0)) {
            impl->fill();
            return;
        }
        winding = info[0];
        if (!winding.prepare())
            return;
        static const char* validValues[] = {
            "nonzero",
            "evenodd",
        };
        if (!isValidEnum(winding, validValues, WTF_ARRAY_LENGTH(validValues), "CanvasFillRule", exceptionState)) {
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->fill(winding);
}

static void fill2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "fill", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    Path2D* path;
    V8StringResource<> winding;
    {
        path = V8Path2D::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!path) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Path2D'.");
            exceptionState.throwIfNeeded();
            return;
        }
        if (UNLIKELY(info.Length() <= 1)) {
            impl->fill(path);
            return;
        }
        winding = info[1];
        if (!winding.prepare())
            return;
        static const char* validValues[] = {
            "nonzero",
            "evenodd",
        };
        if (!isValidEnum(winding, validValues, WTF_ARRAY_LENGTH(validValues), "CanvasFillRule", exceptionState)) {
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->fill(path, winding);
}

static void fillMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "fill", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    switch (std::min(2, info.Length())) {
    case 0:
        if (true) {
            fill1Method(info);
            return;
        }
        break;
    case 1:
        if (info[0]->IsUndefined()) {
            fill1Method(info);
            return;
        }
        if (V8Path2D::hasInstance(info[0], info.GetIsolate())) {
            fill2Method(info);
            return;
        }
        if (true) {
            fill1Method(info);
            return;
        }
        break;
    case 2:
        if (true) {
            fill2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void fillMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::fillMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void stroke1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    impl->stroke();
}

static void stroke2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    Path2D* path;
    {
        path = V8Path2D::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!path) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("stroke", "CanvasRenderingContext2D", "parameter 1 is not of type 'Path2D'."));
            return;
        }
    }
    impl->stroke(path);
}

static void strokeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "stroke", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    switch (std::min(1, info.Length())) {
    case 0:
        if (true) {
            stroke1Method(info);
            return;
        }
        break;
    case 1:
        if (true) {
            stroke2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void strokeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::strokeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void drawFocusIfNeeded1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    Element* element;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("drawFocusIfNeeded", "CanvasRenderingContext2D", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    impl->drawFocusIfNeeded(element);
}

static void drawFocusIfNeeded2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    Path2D* path;
    Element* element;
    {
        path = V8Path2D::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!path) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("drawFocusIfNeeded", "CanvasRenderingContext2D", "parameter 1 is not of type 'Path2D'."));
            return;
        }
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("drawFocusIfNeeded", "CanvasRenderingContext2D", "parameter 2 is not of type 'Element'."));
            return;
        }
    }
    impl->drawFocusIfNeeded(path, element);
}

static void drawFocusIfNeededMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawFocusIfNeeded", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    switch (std::min(2, info.Length())) {
    case 1:
        if (true) {
            drawFocusIfNeeded1Method(info);
            return;
        }
        break;
    case 2:
        if (true) {
            drawFocusIfNeeded2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    if (info.Length() < 1) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void drawFocusIfNeededMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::drawFocusIfNeededMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void scrollPathIntoViewMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    Path2D* path;
    {
        if (UNLIKELY(info.Length() <= 0)) {
            impl->scrollPathIntoView();
            return;
        }
        path = V8Path2D::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!path) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("scrollPathIntoView", "CanvasRenderingContext2D", "parameter 1 is not of type 'Path2D'."));
            return;
        }
    }
    impl->scrollPathIntoView(path);
}

static void scrollPathIntoViewMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::scrollPathIntoViewMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void clip1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "clip", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    V8StringResource<> winding;
    {
        if (UNLIKELY(info.Length() <= 0)) {
            impl->clip();
            return;
        }
        winding = info[0];
        if (!winding.prepare())
            return;
        static const char* validValues[] = {
            "nonzero",
            "evenodd",
        };
        if (!isValidEnum(winding, validValues, WTF_ARRAY_LENGTH(validValues), "CanvasFillRule", exceptionState)) {
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->clip(winding);
}

static void clip2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "clip", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    Path2D* path;
    V8StringResource<> winding;
    {
        path = V8Path2D::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!path) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Path2D'.");
            exceptionState.throwIfNeeded();
            return;
        }
        if (UNLIKELY(info.Length() <= 1)) {
            impl->clip(path);
            return;
        }
        winding = info[1];
        if (!winding.prepare())
            return;
        static const char* validValues[] = {
            "nonzero",
            "evenodd",
        };
        if (!isValidEnum(winding, validValues, WTF_ARRAY_LENGTH(validValues), "CanvasFillRule", exceptionState)) {
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->clip(path, winding);
}

static void clipMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "clip", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    switch (std::min(2, info.Length())) {
    case 0:
        if (true) {
            clip1Method(info);
            return;
        }
        break;
    case 1:
        if (info[0]->IsUndefined()) {
            clip1Method(info);
            return;
        }
        if (V8Path2D::hasInstance(info[0], info.GetIsolate())) {
            clip2Method(info);
            return;
        }
        if (true) {
            clip1Method(info);
            return;
        }
        break;
    case 2:
        if (true) {
            clip2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void clipMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::clipMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isPointInPath1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isPointInPath", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    V8StringResource<> winding;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        if (UNLIKELY(info.Length() <= 2)) {
            v8SetReturnValueBool(info, impl->isPointInPath(x, y));
            return;
        }
        winding = info[2];
        if (!winding.prepare())
            return;
        static const char* validValues[] = {
            "nonzero",
            "evenodd",
        };
        if (!isValidEnum(winding, validValues, WTF_ARRAY_LENGTH(validValues), "CanvasFillRule", exceptionState)) {
            exceptionState.throwIfNeeded();
            return;
        }
    }
    v8SetReturnValueBool(info, impl->isPointInPath(x, y, winding));
}

static void isPointInPath2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isPointInPath", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    Path2D* path;
    float x;
    float y;
    V8StringResource<> winding;
    {
        path = V8Path2D::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!path) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Path2D'.");
            exceptionState.throwIfNeeded();
            return;
        }
        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        if (UNLIKELY(info.Length() <= 3)) {
            v8SetReturnValueBool(info, impl->isPointInPath(path, x, y));
            return;
        }
        winding = info[3];
        if (!winding.prepare())
            return;
        static const char* validValues[] = {
            "nonzero",
            "evenodd",
        };
        if (!isValidEnum(winding, validValues, WTF_ARRAY_LENGTH(validValues), "CanvasFillRule", exceptionState)) {
            exceptionState.throwIfNeeded();
            return;
        }
    }
    v8SetReturnValueBool(info, impl->isPointInPath(path, x, y, winding));
}

static void isPointInPathMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isPointInPath", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    switch (std::min(4, info.Length())) {
    case 2:
        if (true) {
            isPointInPath1Method(info);
            return;
        }
        break;
    case 3:
        if (V8Path2D::hasInstance(info[0], info.GetIsolate())) {
            isPointInPath2Method(info);
            return;
        }
        if (true) {
            isPointInPath1Method(info);
            return;
        }
        break;
    case 4:
        if (true) {
            isPointInPath2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    if (info.Length() < 2) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void isPointInPathMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::isPointInPathMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isPointInStroke1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isPointInStroke", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueBool(info, impl->isPointInStroke(x, y));
}

static void isPointInStroke2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isPointInStroke", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    Path2D* path;
    float x;
    float y;
    {
        path = V8Path2D::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!path) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Path2D'.");
            exceptionState.throwIfNeeded();
            return;
        }
        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueBool(info, impl->isPointInStroke(path, x, y));
}

static void isPointInStrokeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isPointInStroke", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    switch (std::min(3, info.Length())) {
    case 2:
        if (true) {
            isPointInStroke1Method(info);
            return;
        }
        break;
    case 3:
        if (true) {
            isPointInStroke2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    if (info.Length() < 2) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void isPointInStrokeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::isPointInStrokeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void fillTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "fillText", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    V8StringResource<> text;
    float x;
    float y;
    float maxWidth;
    {
        text = info[0];
        if (!text.prepare())
            return;
        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        if (UNLIKELY(info.Length() <= 3)) {
            impl->fillText(text, x, y);
            return;
        }
        maxWidth = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->fillText(text, x, y, maxWidth);
}

static void fillTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::fillTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void strokeTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "strokeText", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    V8StringResource<> text;
    float x;
    float y;
    float maxWidth;
    {
        text = info[0];
        if (!text.prepare())
            return;
        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        if (UNLIKELY(info.Length() <= 3)) {
            impl->strokeText(text, x, y);
            return;
        }
        maxWidth = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->strokeText(text, x, y, maxWidth);
}

static void strokeTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::strokeTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void measureTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "measureText", "CanvasRenderingContext2D", 1, info.Length()), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    V8StringResource<> text;
    {
        text = info[0];
        if (!text.prepare())
            return;
    }
    v8SetReturnValue(info, impl->measureText(text));
}

static void measureTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::measureTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void drawImage1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrImageBitmap image;
    float x;
    float y;
    {
        V8HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrImageBitmap::toImpl(info.GetIsolate(), info[0], image, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->drawImage(image, x, y, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrImageBitmap image;
    float x;
    float y;
    float width;
    float height;
    {
        V8HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrImageBitmap::toImpl(info.GetIsolate(), info[0], image, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        x = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        width = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        height = toFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->drawImage(image, x, y, width, height, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImage3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrImageBitmap image;
    float sx;
    float sy;
    float sw;
    float sh;
    float dx;
    float dy;
    float dw;
    float dh;
    {
        V8HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrImageBitmap::toImpl(info.GetIsolate(), info[0], image, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        sx = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        sy = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        sw = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        sh = toFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        dx = toFloat(info.GetIsolate(), info[5], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        dy = toFloat(info.GetIsolate(), info[6], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        dw = toFloat(info.GetIsolate(), info[7], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        dh = toFloat(info.GetIsolate(), info[8], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void drawImageMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "drawImage", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    switch (std::min(9, info.Length())) {
    case 3:
        if (true) {
            drawImage1Method(info);
            return;
        }
        break;
    case 5:
        if (true) {
            drawImage2Method(info);
            return;
        }
        break;
    case 9:
        if (true) {
            drawImage3Method(info);
            return;
        }
        break;
    default:
        if (info.Length() >= 3) {
            setArityTypeError(exceptionState, "[3, 5, 9]", info.Length());
            exceptionState.throwIfNeeded();
            return;
        }
        break;
    }
    if (info.Length() < 3) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void drawImageMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::drawImageMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void addHitRegionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "addHitRegion", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    HitRegionOptions options;
    {
        if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
            exceptionState.throwTypeError("parameter 1 ('options') is not an object.");
            exceptionState.throwIfNeeded();
            return;
        }
        V8HitRegionOptions::toImpl(info.GetIsolate(), info[0], options, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->addHitRegion(options, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void addHitRegionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::addHitRegionMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void removeHitRegionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "removeHitRegion", "CanvasRenderingContext2D", 1, info.Length()), info.GetIsolate());
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    V8StringResource<> id;
    {
        id = info[0];
        if (!id.prepare())
            return;
    }
    impl->removeHitRegion(id);
}

static void removeHitRegionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::removeHitRegionMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void clearHitRegionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    impl->clearHitRegions();
}

static void clearHitRegionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::clearHitRegionsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void createImageData1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    ImageData* imagedata;
    {
        imagedata = V8ImageData::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!imagedata) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("createImageData", "CanvasRenderingContext2D", "parameter 1 is not of type 'ImageData'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->createImageData(imagedata));
}

static void createImageData2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createImageData", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float sw;
    float sh;
    {
        sw = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        sh = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    RawPtr<ImageData> result = impl->createImageData(sw, sh, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void createImageDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createImageData", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    switch (std::min(2, info.Length())) {
    case 1:
        if (true) {
            createImageData1Method(info);
            return;
        }
        break;
    case 2:
        if (true) {
            createImageData2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    if (info.Length() < 1) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void createImageDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::createImageDataMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void getImageDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "getImageData", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        setMinimumArityTypeError(exceptionState, 4, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float sx;
    float sy;
    float sw;
    float sh;
    {
        sx = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        sy = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        sw = toRestrictedFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        sh = toRestrictedFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    RawPtr<ImageData> result = impl->getImageData(sx, sy, sw, sh, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void getImageDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::getImageDataMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void putImageData1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "putImageData", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    ImageData* imagedata;
    float dx;
    float dy;
    {
        imagedata = V8ImageData::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!imagedata) {
            exceptionState.throwTypeError("parameter 1 is not of type 'ImageData'.");
            exceptionState.throwIfNeeded();
            return;
        }
        dx = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        dy = toRestrictedFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->putImageData(imagedata, dx, dy);
}

static void putImageData2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "putImageData", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    ImageData* imagedata;
    float dx;
    float dy;
    float dirtyX;
    float dirtyY;
    float dirtyWidth;
    float dirtyHeight;
    {
        imagedata = V8ImageData::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!imagedata) {
            exceptionState.throwTypeError("parameter 1 is not of type 'ImageData'.");
            exceptionState.throwIfNeeded();
            return;
        }
        dx = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        dy = toRestrictedFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        dirtyX = toRestrictedFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        dirtyY = toRestrictedFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        dirtyWidth = toRestrictedFloat(info.GetIsolate(), info[5], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        dirtyHeight = toRestrictedFloat(info.GetIsolate(), info[6], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
}

static void putImageDataMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "putImageData", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    switch (std::min(7, info.Length())) {
    case 3:
        if (true) {
            putImageData1Method(info);
            return;
        }
        break;
    case 7:
        if (true) {
            putImageData2Method(info);
            return;
        }
        break;
    default:
        if (info.Length() >= 3) {
            setArityTypeError(exceptionState, "[3, 7]", info.Length());
            exceptionState.throwIfNeeded();
            return;
        }
        break;
    }
    if (info.Length() < 3) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void putImageDataMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::putImageDataMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isContextLostMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    v8SetReturnValueBool(info, impl->isContextLost());
}

static void isContextLostMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::isContextLostMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void getContextAttributesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    Canvas2DContextAttributes result;
    impl->getContextAttributes(result);
    v8SetReturnValue(info, result);
}

static void getContextAttributesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::getContextAttributesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setLineDashMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setLineDash", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    Vector<float> dash;
    {
        dash = toImplArray<Vector<float>>(info[0], 1, info.GetIsolate(), exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setLineDash(dash);
}

static void setLineDashMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::setLineDashMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void getLineDashMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    v8SetReturnValue(info, toV8(impl->getLineDash(), info.Holder(), info.GetIsolate()));
}

static void getLineDashMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::getLineDashMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void closePathMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    impl->closePath();
}

static void closePathMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::closePathMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void moveToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "moveTo", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->moveTo(x, y);
}

static void moveToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::moveToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lineToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "lineTo", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->lineTo(x, y);
}

static void lineToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::lineToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void quadraticCurveToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "quadraticCurveTo", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        setMinimumArityTypeError(exceptionState, 4, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float cpx;
    float cpy;
    float x;
    float y;
    {
        cpx = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        cpy = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        x = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->quadraticCurveTo(cpx, cpy, x, y);
}

static void quadraticCurveToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::quadraticCurveToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void bezierCurveToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bezierCurveTo", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 6)) {
        setMinimumArityTypeError(exceptionState, 6, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float cp1x;
    float cp1y;
    float cp2x;
    float cp2y;
    float x;
    float y;
    {
        cp1x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        cp1y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        cp2x = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        cp2y = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        x = toFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[5], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
}

static void bezierCurveToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::bezierCurveToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void arcToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "arcTo", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        setMinimumArityTypeError(exceptionState, 5, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x1;
    float y1;
    float x2;
    float y2;
    float radius;
    {
        x1 = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y1 = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        x2 = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y2 = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        radius = toFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->arcTo(x1, y1, x2, y2, radius, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void arcToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::arcToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void rectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "rect", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        setMinimumArityTypeError(exceptionState, 4, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    float width;
    float height;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        width = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        height = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->rect(x, y, width, height);
}

static void rectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::rectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void arcMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "arc", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        setMinimumArityTypeError(exceptionState, 5, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    float radius;
    float startAngle;
    float endAngle;
    bool anticlockwise;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        radius = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        startAngle = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        endAngle = toFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        anticlockwise = toBoolean(info.GetIsolate(), info[5], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->arc(x, y, radius, startAngle, endAngle, anticlockwise, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void arcMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::arcMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void ellipseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "ellipse", "CanvasRenderingContext2D", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 7)) {
        setMinimumArityTypeError(exceptionState, 7, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    CanvasRenderingContext2D* impl = V8CanvasRenderingContext2D::toImpl(info.Holder());
    float x;
    float y;
    float radiusX;
    float radiusY;
    float rotation;
    float startAngle;
    float endAngle;
    bool anticlockwise;
    {
        x = toFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        radiusX = toFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        radiusY = toFloat(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        rotation = toFloat(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        startAngle = toFloat(info.GetIsolate(), info[5], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        endAngle = toFloat(info.GetIsolate(), info[6], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        anticlockwise = toBoolean(info.GetIsolate(), info[7], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void ellipseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    CanvasRenderingContext2DV8Internal::ellipseMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

} // namespace CanvasRenderingContext2DV8Internal

void V8CanvasRenderingContext2D::visitDOMWrapper(v8::Isolate* isolate, ScriptWrappable* scriptWrappable, const v8::Persistent<v8::Object>& wrapper)
{
    CanvasRenderingContext2D* impl = scriptWrappable->toImpl<CanvasRenderingContext2D>();
    // The canvas() method may return a reference or a pointer.
    if (Node* owner = WTF::getPtr(impl->canvas())) {
        Node* root = V8GCController::opaqueRootForGC(isolate, owner);
        isolate->SetReferenceFromGroup(v8::UniqueId(reinterpret_cast<intptr_t>(root)), wrapper);
        return;
    }
}

static const V8DOMConfiguration::AccessorConfiguration V8CanvasRenderingContext2DAccessors[] = {
    {"canvas", CanvasRenderingContext2DV8Internal::canvasAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"globalAlpha", CanvasRenderingContext2DV8Internal::globalAlphaAttributeGetterCallback, CanvasRenderingContext2DV8Internal::globalAlphaAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"globalCompositeOperation", CanvasRenderingContext2DV8Internal::globalCompositeOperationAttributeGetterCallback, CanvasRenderingContext2DV8Internal::globalCompositeOperationAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"webkitImageSmoothingEnabled", CanvasRenderingContext2DV8Internal::webkitImageSmoothingEnabledAttributeGetterCallback, CanvasRenderingContext2DV8Internal::webkitImageSmoothingEnabledAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"imageSmoothingEnabled", CanvasRenderingContext2DV8Internal::imageSmoothingEnabledAttributeGetterCallback, CanvasRenderingContext2DV8Internal::imageSmoothingEnabledAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"strokeStyle", CanvasRenderingContext2DV8Internal::strokeStyleAttributeGetterCallback, CanvasRenderingContext2DV8Internal::strokeStyleAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"fillStyle", CanvasRenderingContext2DV8Internal::fillStyleAttributeGetterCallback, CanvasRenderingContext2DV8Internal::fillStyleAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"shadowOffsetX", CanvasRenderingContext2DV8Internal::shadowOffsetXAttributeGetterCallback, CanvasRenderingContext2DV8Internal::shadowOffsetXAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"shadowOffsetY", CanvasRenderingContext2DV8Internal::shadowOffsetYAttributeGetterCallback, CanvasRenderingContext2DV8Internal::shadowOffsetYAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"shadowBlur", CanvasRenderingContext2DV8Internal::shadowBlurAttributeGetterCallback, CanvasRenderingContext2DV8Internal::shadowBlurAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"shadowColor", CanvasRenderingContext2DV8Internal::shadowColorAttributeGetterCallback, CanvasRenderingContext2DV8Internal::shadowColorAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"lineWidth", CanvasRenderingContext2DV8Internal::lineWidthAttributeGetterCallback, CanvasRenderingContext2DV8Internal::lineWidthAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"lineCap", CanvasRenderingContext2DV8Internal::lineCapAttributeGetterCallback, CanvasRenderingContext2DV8Internal::lineCapAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"lineJoin", CanvasRenderingContext2DV8Internal::lineJoinAttributeGetterCallback, CanvasRenderingContext2DV8Internal::lineJoinAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"miterLimit", CanvasRenderingContext2DV8Internal::miterLimitAttributeGetterCallback, CanvasRenderingContext2DV8Internal::miterLimitAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"lineDashOffset", CanvasRenderingContext2DV8Internal::lineDashOffsetAttributeGetterCallback, CanvasRenderingContext2DV8Internal::lineDashOffsetAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"font", CanvasRenderingContext2DV8Internal::fontAttributeGetterCallback, CanvasRenderingContext2DV8Internal::fontAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"textAlign", CanvasRenderingContext2DV8Internal::textAlignAttributeGetterCallback, CanvasRenderingContext2DV8Internal::textAlignAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"textBaseline", CanvasRenderingContext2DV8Internal::textBaselineAttributeGetterCallback, CanvasRenderingContext2DV8Internal::textBaselineAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
};

static const V8DOMConfiguration::MethodConfiguration V8CanvasRenderingContext2DMethods[] = {
    {"save", CanvasRenderingContext2DV8Internal::saveMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"restore", CanvasRenderingContext2DV8Internal::restoreMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"scale", CanvasRenderingContext2DV8Internal::scaleMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"rotate", CanvasRenderingContext2DV8Internal::rotateMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"translate", CanvasRenderingContext2DV8Internal::translateMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"transform", CanvasRenderingContext2DV8Internal::transformMethodCallback, 0, 6, V8DOMConfiguration::ExposedToAllScripts},
    {"setTransform", CanvasRenderingContext2DV8Internal::setTransformMethodCallback, 0, 6, V8DOMConfiguration::ExposedToAllScripts},
    {"resetTransform", CanvasRenderingContext2DV8Internal::resetTransformMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"createLinearGradient", CanvasRenderingContext2DV8Internal::createLinearGradientMethodCallback, 0, 4, V8DOMConfiguration::ExposedToAllScripts},
    {"createRadialGradient", CanvasRenderingContext2DV8Internal::createRadialGradientMethodCallback, 0, 6, V8DOMConfiguration::ExposedToAllScripts},
    {"createPattern", CanvasRenderingContext2DV8Internal::createPatternMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"clearRect", CanvasRenderingContext2DV8Internal::clearRectMethodCallback, 0, 4, V8DOMConfiguration::ExposedToAllScripts},
    {"fillRect", CanvasRenderingContext2DV8Internal::fillRectMethodCallback, 0, 4, V8DOMConfiguration::ExposedToAllScripts},
    {"strokeRect", CanvasRenderingContext2DV8Internal::strokeRectMethodCallback, 0, 4, V8DOMConfiguration::ExposedToAllScripts},
    {"beginPath", CanvasRenderingContext2DV8Internal::beginPathMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"fill", CanvasRenderingContext2DV8Internal::fillMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"stroke", CanvasRenderingContext2DV8Internal::strokeMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"drawFocusIfNeeded", CanvasRenderingContext2DV8Internal::drawFocusIfNeededMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"clip", CanvasRenderingContext2DV8Internal::clipMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"isPointInPath", CanvasRenderingContext2DV8Internal::isPointInPathMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"isPointInStroke", CanvasRenderingContext2DV8Internal::isPointInStrokeMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"fillText", CanvasRenderingContext2DV8Internal::fillTextMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"strokeText", CanvasRenderingContext2DV8Internal::strokeTextMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"measureText", CanvasRenderingContext2DV8Internal::measureTextMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"drawImage", CanvasRenderingContext2DV8Internal::drawImageMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"createImageData", CanvasRenderingContext2DV8Internal::createImageDataMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"getImageData", CanvasRenderingContext2DV8Internal::getImageDataMethodCallback, 0, 4, V8DOMConfiguration::ExposedToAllScripts},
    {"putImageData", CanvasRenderingContext2DV8Internal::putImageDataMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"getContextAttributes", CanvasRenderingContext2DV8Internal::getContextAttributesMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"setLineDash", CanvasRenderingContext2DV8Internal::setLineDashMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"getLineDash", CanvasRenderingContext2DV8Internal::getLineDashMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"closePath", CanvasRenderingContext2DV8Internal::closePathMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"moveTo", CanvasRenderingContext2DV8Internal::moveToMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"lineTo", CanvasRenderingContext2DV8Internal::lineToMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"quadraticCurveTo", CanvasRenderingContext2DV8Internal::quadraticCurveToMethodCallback, 0, 4, V8DOMConfiguration::ExposedToAllScripts},
    {"bezierCurveTo", CanvasRenderingContext2DV8Internal::bezierCurveToMethodCallback, 0, 6, V8DOMConfiguration::ExposedToAllScripts},
    {"arcTo", CanvasRenderingContext2DV8Internal::arcToMethodCallback, 0, 5, V8DOMConfiguration::ExposedToAllScripts},
    {"rect", CanvasRenderingContext2DV8Internal::rectMethodCallback, 0, 4, V8DOMConfiguration::ExposedToAllScripts},
    {"arc", CanvasRenderingContext2DV8Internal::arcMethodCallback, 0, 5, V8DOMConfiguration::ExposedToAllScripts},
    {"ellipse", CanvasRenderingContext2DV8Internal::ellipseMethodCallback, 0, 7, V8DOMConfiguration::ExposedToAllScripts},
};

static void installV8CanvasRenderingContext2DTemplate(v8::Local<v8::FunctionTemplate> functionTemplate, v8::Isolate* isolate)
{
    functionTemplate->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = V8DOMConfiguration::installDOMClassTemplate(isolate, functionTemplate, "CanvasRenderingContext2D", v8::Local<v8::FunctionTemplate>(), V8CanvasRenderingContext2D::internalFieldCount,
        0, 0,
        V8CanvasRenderingContext2DAccessors, WTF_ARRAY_LENGTH(V8CanvasRenderingContext2DAccessors),
        V8CanvasRenderingContext2DMethods, WTF_ARRAY_LENGTH(V8CanvasRenderingContext2DMethods));
    v8::Local<v8::ObjectTemplate> instanceTemplate = functionTemplate->InstanceTemplate();
    ALLOW_UNUSED_LOCAL(instanceTemplate);
    v8::Local<v8::ObjectTemplate> prototypeTemplate = functionTemplate->PrototypeTemplate();
    ALLOW_UNUSED_LOCAL(prototypeTemplate);
    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        static const V8DOMConfiguration::AccessorConfiguration accessorConfiguration =\
        {"currentTransform", CanvasRenderingContext2DV8Internal::currentTransformAttributeGetterCallback, CanvasRenderingContext2DV8Internal::currentTransformAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
        V8DOMConfiguration::installAccessor(isolate, instanceTemplate, prototypeTemplate, functionTemplate, defaultSignature, accessorConfiguration);
    }
    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        static const V8DOMConfiguration::AccessorConfiguration accessorConfiguration =\
        {"filter", CanvasRenderingContext2DV8Internal::filterAttributeGetterCallback, CanvasRenderingContext2DV8Internal::filterAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
        V8DOMConfiguration::installAccessor(isolate, instanceTemplate, prototypeTemplate, functionTemplate, defaultSignature, accessorConfiguration);
    }
    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        static const V8DOMConfiguration::AccessorConfiguration accessorConfiguration =\
        {"direction", CanvasRenderingContext2DV8Internal::directionAttributeGetterCallback, CanvasRenderingContext2DV8Internal::directionAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
        V8DOMConfiguration::installAccessor(isolate, instanceTemplate, prototypeTemplate, functionTemplate, defaultSignature, accessorConfiguration);
    }
    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        const V8DOMConfiguration::MethodConfiguration scrollPathIntoViewMethodConfiguration = {
            "scrollPathIntoView", CanvasRenderingContext2DV8Internal::scrollPathIntoViewMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts,
        };
        V8DOMConfiguration::installMethod(isolate, prototypeTemplate, defaultSignature, v8::None, scrollPathIntoViewMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        const V8DOMConfiguration::MethodConfiguration addHitRegionMethodConfiguration = {
            "addHitRegion", CanvasRenderingContext2DV8Internal::addHitRegionMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts,
        };
        V8DOMConfiguration::installMethod(isolate, prototypeTemplate, defaultSignature, v8::None, addHitRegionMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        const V8DOMConfiguration::MethodConfiguration removeHitRegionMethodConfiguration = {
            "removeHitRegion", CanvasRenderingContext2DV8Internal::removeHitRegionMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts,
        };
        V8DOMConfiguration::installMethod(isolate, prototypeTemplate, defaultSignature, v8::None, removeHitRegionMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        const V8DOMConfiguration::MethodConfiguration clearHitRegionsMethodConfiguration = {
            "clearHitRegions", CanvasRenderingContext2DV8Internal::clearHitRegionsMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts,
        };
        V8DOMConfiguration::installMethod(isolate, prototypeTemplate, defaultSignature, v8::None, clearHitRegionsMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::experimentalCanvasFeaturesEnabled()) {
        const V8DOMConfiguration::MethodConfiguration isContextLostMethodConfiguration = {
            "isContextLost", CanvasRenderingContext2DV8Internal::isContextLostMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts,
        };
        V8DOMConfiguration::installMethod(isolate, prototypeTemplate, defaultSignature, v8::None, isContextLostMethodConfiguration);
    }

    // Custom toString template
#if V8_MAJOR_VERSION < 7
    functionTemplate->Set(v8AtomicString(isolate, "toString"), V8PerIsolateData::from(isolate)->toStringTemplate());
#endif
}

v8::Local<v8::FunctionTemplate> V8CanvasRenderingContext2D::domTemplate(v8::Isolate* isolate)
{
    return V8DOMConfiguration::domClassTemplate(isolate, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), installV8CanvasRenderingContext2DTemplate);
}

bool V8CanvasRenderingContext2D::hasInstance(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Local<v8::Object> V8CanvasRenderingContext2D::findInstanceInPrototypeChain(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

CanvasRenderingContext2D* V8CanvasRenderingContext2D::toImplWithTypeCheck(v8::Isolate* isolate, v8::Local<v8::Value> value)
{
    return hasInstance(value, isolate) ? toImpl(v8::Local<v8::Object>::Cast(value)) : 0;
}

void V8CanvasRenderingContext2D::refObject(ScriptWrappable* scriptWrappable)
{
#if !ENABLE(OILPAN)
    scriptWrappable->toImpl<CanvasRenderingContext2D>()->ref();
#endif
}

void V8CanvasRenderingContext2D::derefObject(ScriptWrappable* scriptWrappable)
{
#if !ENABLE(OILPAN)
    scriptWrappable->toImpl<CanvasRenderingContext2D>()->deref();
#endif
}

} // namespace blink
