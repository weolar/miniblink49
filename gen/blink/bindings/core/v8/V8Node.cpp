// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#include "config.h"
#include "V8Node.h"

#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/V8DOMConfiguration.h"
#include "bindings/core/v8/V8Document.h"
#include "bindings/core/v8/V8Element.h"
#include "bindings/core/v8/V8Node.h"
#include "bindings/core/v8/V8NodeList.h"
#include "bindings/core/v8/V8ObjectConstructor.h"
#include "core/dom/ContextFeatures.h"
#include "core/dom/Document.h"
#include "core/dom/NameNodeList.h"
#include "core/dom/NodeList.h"
#include "core/dom/StaticNodeList.h"
#include "core/dom/custom/CustomElementProcessingStack.h"
#include "core/frame/UseCounter.h"
#include "core/html/LabelsNodeList.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "platform/TraceEvent.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace blink {

// Suppress warning: global constructors, because struct WrapperTypeInfo is trivial
// and does not depend on another global objects.
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif
const WrapperTypeInfo V8Node::wrapperTypeInfo = { gin::kEmbedderBlink, V8Node::domTemplate, V8Node::refObject, V8Node::derefObject, V8Node::trace, 0, 0, V8Node::preparePrototypeObject, V8Node::installConditionallyEnabledProperties, "Node", &V8EventTarget::wrapperTypeInfo, WrapperTypeInfo::WrapperTypeObjectPrototype, WrapperTypeInfo::NodeClassId, WrapperTypeInfo::InheritFromEventTarget, WrapperTypeInfo::Dependent, WrapperTypeInfo::WillBeGarbageCollectedObject };
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic pop
#endif

// This static member must be declared by DEFINE_WRAPPERTYPEINFO in Node.h.
// For details, see the comment of DEFINE_WRAPPERTYPEINFO in
// bindings/core/v8/ScriptWrappable.h.
const WrapperTypeInfo& Node::s_wrapperTypeInfo = V8Node::wrapperTypeInfo;

namespace NodeV8Internal {

static void nodeTypeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueUnsigned(info, impl->nodeType());
}

static void nodeTypeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::nodeTypeAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void nodeNameAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueString(info, impl->nodeName(), info.GetIsolate());
}

static void nodeNameAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::nodeNameAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void baseURIAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueStringOrNull(info, impl->baseURI(), info.GetIsolate());
}

static void baseURIAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::baseURIAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void ownerDocumentAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->ownerDocument()), impl);
}

static void ownerDocumentAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::ownerDocumentAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void ownerDocumentAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->ownerDocument()));
}

static void ownerDocumentAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::ownerDocumentAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void parentNodeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->parentNode()), impl);
}

static void parentNodeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::parentNodeAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void parentNodeAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->parentNode()));
}

static void parentNodeAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::parentNodeAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void parentElementAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->parentElement()), impl);
}

static void parentElementAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::parentElementAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void parentElementAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->parentElement()));
}

static void parentElementAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::parentElementAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void childNodesAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->childNodes()), impl);
}

static void childNodesAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::childNodesAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void childNodesAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->childNodes()));
}

static void childNodesAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::childNodesAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void firstChildAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->firstChild()), impl);
}

static void firstChildAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::firstChildAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void firstChildAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->firstChild()));
}

static void firstChildAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::firstChildAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lastChildAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->lastChild()), impl);
}

static void lastChildAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::lastChildAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lastChildAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->lastChild()));
}

static void lastChildAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::lastChildAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void previousSiblingAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->previousSibling()), impl);
}

static void previousSiblingAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::previousSiblingAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void previousSiblingAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->previousSibling()));
}

static void previousSiblingAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::previousSiblingAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void nextSiblingAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->nextSibling()), impl);
}

static void nextSiblingAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::nextSiblingAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void nextSiblingAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->nextSibling()));
}

static void nextSiblingAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::nextSiblingAttributeGetterForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void nodeValueAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueStringOrNull(info, impl->nodeValue(), info.GetIsolate());
}

static void nodeValueAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::nodeValueAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void nodeValueAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    V8StringResource<TreatNullAsNullString> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    impl->setNodeValue(cppValue);
}

static void nodeValueAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    NodeV8Internal::nodeValueAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void textContentAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueStringOrNull(info, impl->textContent(), info.GetIsolate());
}

static void textContentAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    NodeV8Internal::textContentAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void textContentAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    V8StringResource<TreatNullAndUndefinedAsNullString> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    impl->setTextContent(cppValue);
}

static void textContentAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMSetter");
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    NodeV8Internal::textContentAttributeSetter(v8Value, info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void namespaceURIAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueStringOrNull(info, impl->namespaceURI(), info.GetIsolate());
}

static void namespaceURIAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::NodeNamespaceURI);
    NodeV8Internal::namespaceURIAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void localNameAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Node* impl = V8Node::toImpl(holder);
    v8SetReturnValueStringOrNull(info, impl->localName(), info.GetIsolate());
}

static void localNameAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::NodeLocalName);
    NodeV8Internal::localNameAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void hasChildNodesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Node* impl = V8Node::toImpl(info.Holder());
    v8SetReturnValueBool(info, impl->hasChildren());
}

static void hasChildNodesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::hasChildNodesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void normalizeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Node* impl = V8Node::toImpl(info.Holder());
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    impl->normalize();
}

static void normalizeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::normalizeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void cloneNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "cloneNode", "Node", info.Holder(), info.GetIsolate());
    Node* impl = V8Node::toImpl(info.Holder());
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    bool deep;
    {
        if (UNLIKELY(info.Length() <= 0)) {
            v8SetReturnValueFast(info, WTF::getPtr(impl->cloneNode()), impl);
            return;
        }
        deep = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueFast(info, WTF::getPtr(impl->cloneNode(deep)), impl);
}

static void cloneNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::cloneNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isEqualNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "isEqualNode", "Node", 1, info.Length()), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isEqualNode", "Node", "parameter 1 is not of type 'Node'."));
            return;
        }
    }
    v8SetReturnValueBool(info, impl->isEqualNode(node));
}

static void isEqualNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::isEqualNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void compareDocumentPositionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "compareDocumentPosition", "Node", 1, info.Length()), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    Node* other;
    {
        other = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!other) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("compareDocumentPosition", "Node", "parameter 1 is not of type 'Node'."));
            return;
        }
    }
    v8SetReturnValueUnsigned(info, impl->compareDocumentPosition(other));
}

static void compareDocumentPositionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::compareDocumentPositionMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void containsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "contains", "Node", 1, info.Length()), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    Node* other;
    {
        other = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!other && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("contains", "Node", "parameter 1 is not of type 'Node'."));
            return;
        }
    }
    v8SetReturnValueBool(info, impl->contains(other));
}

static void containsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::containsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lookupPrefixMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "lookupPrefix", "Node", 1, info.Length()), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    V8StringResource<TreatNullAsNullString> namespaceURI;
    {
        namespaceURI = info[0];
        if (!namespaceURI.prepare())
            return;
    }
    v8SetReturnValueStringOrNull(info, impl->lookupPrefix(namespaceURI), info.GetIsolate());
}

static void lookupPrefixMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::lookupPrefixMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lookupNamespaceURIMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "lookupNamespaceURI", "Node", 1, info.Length()), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    V8StringResource<TreatNullAsNullString> prefix;
    {
        prefix = info[0];
        if (!prefix.prepare())
            return;
    }
    v8SetReturnValueStringOrNull(info, impl->lookupNamespaceURI(prefix), info.GetIsolate());
}

static void lookupNamespaceURIMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::lookupNamespaceURIMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isDefaultNamespaceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "isDefaultNamespace", "Node", 1, info.Length()), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    V8StringResource<TreatNullAsNullString> namespaceURI;
    {
        namespaceURI = info[0];
        if (!namespaceURI.prepare())
            return;
    }
    v8SetReturnValueBool(info, impl->isDefaultNamespace(namespaceURI));
}

static void isDefaultNamespaceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::isDefaultNamespaceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void insertBeforeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "insertBefore", "Node", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    Node* node;
    Node* child;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        child = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!child && !isUndefinedOrNull(info[1])) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->insertBefore(node, child, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, WTF::getPtr(result.release()), impl);
}

static void insertBeforeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::insertBeforeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void insertBeforeMethodForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "insertBefore", "Node", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    Node* node;
    Node* child;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        child = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!child && !isUndefinedOrNull(info[1])) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->insertBefore(node, child, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueForMainWorld(info, WTF::getPtr(result.release()));
}

static void insertBeforeMethodCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::insertBeforeMethodForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void appendChildMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "appendChild", "Node", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->appendChild(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, WTF::getPtr(result.release()), impl);
}

static void appendChildMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::appendChildMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void appendChildMethodForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "appendChild", "Node", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->appendChild(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueForMainWorld(info, WTF::getPtr(result.release()));
}

static void appendChildMethodCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::appendChildMethodForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void replaceChildMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "replaceChild", "Node", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    Node* node;
    Node* child;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        child = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!child) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->replaceChild(node, child, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, WTF::getPtr(result.release()), impl);
}

static void replaceChildMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::replaceChildMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void replaceChildMethodForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "replaceChild", "Node", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    Node* node;
    Node* child;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        child = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!child) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->replaceChild(node, child, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueForMainWorld(info, WTF::getPtr(result.release()));
}

static void replaceChildMethodCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::replaceChildMethodForMainWorld(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void removeChildMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "removeChild", "Node", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    Node* child;
    {
        child = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!child) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->removeChild(child, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }

    v8SetReturnValueFast(info, WTF::getPtr(result.release()), impl);
}

static void removeChildMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    NodeV8Internal::removeChildMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isSameNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "isSameNode", "Node", 1, info.Length()), info.GetIsolate());
        return;
    }
    Node* impl = V8Node::toImpl(info.Holder());
    Node* other;
    {
        other = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!other && !isUndefinedOrNull(info[0])) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSameNode", "Node", "parameter 1 is not of type 'Node'."));
            return;
        }
    }
    v8SetReturnValueBool(info, impl->isSameNode(other));
}

static void isSameNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), callingExecutionContext(info.GetIsolate()), UseCounter::NodeIsSameNode);
    NodeV8Internal::isSameNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

} // namespace NodeV8Internal

static const V8DOMConfiguration::AccessorConfiguration V8NodeAccessors[] = {
    {"nodeType", NodeV8Internal::nodeTypeAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"nodeName", NodeV8Internal::nodeNameAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"baseURI", NodeV8Internal::baseURIAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"ownerDocument", NodeV8Internal::ownerDocumentAttributeGetterCallback, 0, NodeV8Internal::ownerDocumentAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"parentNode", NodeV8Internal::parentNodeAttributeGetterCallback, 0, NodeV8Internal::parentNodeAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"parentElement", NodeV8Internal::parentElementAttributeGetterCallback, 0, NodeV8Internal::parentElementAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"childNodes", NodeV8Internal::childNodesAttributeGetterCallback, 0, NodeV8Internal::childNodesAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"firstChild", NodeV8Internal::firstChildAttributeGetterCallback, 0, NodeV8Internal::firstChildAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"lastChild", NodeV8Internal::lastChildAttributeGetterCallback, 0, NodeV8Internal::lastChildAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"previousSibling", NodeV8Internal::previousSiblingAttributeGetterCallback, 0, NodeV8Internal::previousSiblingAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"nextSibling", NodeV8Internal::nextSiblingAttributeGetterCallback, 0, NodeV8Internal::nextSiblingAttributeGetterCallbackForMainWorld, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"nodeValue", NodeV8Internal::nodeValueAttributeGetterCallback, NodeV8Internal::nodeValueAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"textContent", NodeV8Internal::textContentAttributeGetterCallback, NodeV8Internal::textContentAttributeSetterCallback, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"namespaceURI", NodeV8Internal::namespaceURIAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"localName", NodeV8Internal::localNameAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
};

static const V8DOMConfiguration::MethodConfiguration V8NodeMethods[] = {
    {"hasChildNodes", NodeV8Internal::hasChildNodesMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"normalize", NodeV8Internal::normalizeMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"cloneNode", NodeV8Internal::cloneNodeMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"isEqualNode", NodeV8Internal::isEqualNodeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"compareDocumentPosition", NodeV8Internal::compareDocumentPositionMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"contains", NodeV8Internal::containsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"lookupPrefix", NodeV8Internal::lookupPrefixMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"lookupNamespaceURI", NodeV8Internal::lookupNamespaceURIMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"isDefaultNamespace", NodeV8Internal::isDefaultNamespaceMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"insertBefore", NodeV8Internal::insertBeforeMethodCallback, NodeV8Internal::insertBeforeMethodCallbackForMainWorld, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"appendChild", NodeV8Internal::appendChildMethodCallback, NodeV8Internal::appendChildMethodCallbackForMainWorld, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"replaceChild", NodeV8Internal::replaceChildMethodCallback, NodeV8Internal::replaceChildMethodCallbackForMainWorld, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"removeChild", NodeV8Internal::removeChildMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"isSameNode", NodeV8Internal::isSameNodeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
};

static void installV8NodeTemplate(v8::Local<v8::FunctionTemplate> functionTemplate, v8::Isolate* isolate)
{
    functionTemplate->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = V8DOMConfiguration::installDOMClassTemplate(isolate, functionTemplate, "Node", V8EventTarget::domTemplate(isolate), V8Node::internalFieldCount,
        0, 0,
        V8NodeAccessors, WTF_ARRAY_LENGTH(V8NodeAccessors),
        V8NodeMethods, WTF_ARRAY_LENGTH(V8NodeMethods));
    v8::Local<v8::ObjectTemplate> instanceTemplate = functionTemplate->InstanceTemplate();
    ALLOW_UNUSED_LOCAL(instanceTemplate);
    v8::Local<v8::ObjectTemplate> prototypeTemplate = functionTemplate->PrototypeTemplate();
    ALLOW_UNUSED_LOCAL(prototypeTemplate);
    static const V8DOMConfiguration::ConstantConfiguration V8NodeConstants[] = {
        {"ELEMENT_NODE", 1, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"ATTRIBUTE_NODE", 2, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"TEXT_NODE", 3, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"CDATA_SECTION_NODE", 4, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"ENTITY_REFERENCE_NODE", 5, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"ENTITY_NODE", 6, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"PROCESSING_INSTRUCTION_NODE", 7, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"COMMENT_NODE", 8, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"DOCUMENT_NODE", 9, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"DOCUMENT_TYPE_NODE", 10, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"DOCUMENT_FRAGMENT_NODE", 11, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"NOTATION_NODE", 12, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"DOCUMENT_POSITION_DISCONNECTED", 0x01, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"DOCUMENT_POSITION_PRECEDING", 0x02, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"DOCUMENT_POSITION_FOLLOWING", 0x04, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"DOCUMENT_POSITION_CONTAINS", 0x08, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"DOCUMENT_POSITION_CONTAINED_BY", 0x10, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 0x20, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
    };
    V8DOMConfiguration::installConstants(isolate, functionTemplate, prototypeTemplate, V8NodeConstants, WTF_ARRAY_LENGTH(V8NodeConstants));
    static_assert(1 == Node::ELEMENT_NODE, "the value of Node_ELEMENT_NODE does not match with implementation");
    static_assert(2 == Node::ATTRIBUTE_NODE, "the value of Node_ATTRIBUTE_NODE does not match with implementation");
    static_assert(3 == Node::TEXT_NODE, "the value of Node_TEXT_NODE does not match with implementation");
    static_assert(4 == Node::CDATA_SECTION_NODE, "the value of Node_CDATA_SECTION_NODE does not match with implementation");
    static_assert(5 == Node::ENTITY_REFERENCE_NODE, "the value of Node_ENTITY_REFERENCE_NODE does not match with implementation");
    static_assert(6 == Node::ENTITY_NODE, "the value of Node_ENTITY_NODE does not match with implementation");
    static_assert(7 == Node::PROCESSING_INSTRUCTION_NODE, "the value of Node_PROCESSING_INSTRUCTION_NODE does not match with implementation");
    static_assert(8 == Node::COMMENT_NODE, "the value of Node_COMMENT_NODE does not match with implementation");
    static_assert(9 == Node::DOCUMENT_NODE, "the value of Node_DOCUMENT_NODE does not match with implementation");
    static_assert(10 == Node::DOCUMENT_TYPE_NODE, "the value of Node_DOCUMENT_TYPE_NODE does not match with implementation");
    static_assert(11 == Node::DOCUMENT_FRAGMENT_NODE, "the value of Node_DOCUMENT_FRAGMENT_NODE does not match with implementation");
    static_assert(12 == Node::NOTATION_NODE, "the value of Node_NOTATION_NODE does not match with implementation");
    static_assert(0x01 == Node::DOCUMENT_POSITION_DISCONNECTED, "the value of Node_DOCUMENT_POSITION_DISCONNECTED does not match with implementation");
    static_assert(0x02 == Node::DOCUMENT_POSITION_PRECEDING, "the value of Node_DOCUMENT_POSITION_PRECEDING does not match with implementation");
    static_assert(0x04 == Node::DOCUMENT_POSITION_FOLLOWING, "the value of Node_DOCUMENT_POSITION_FOLLOWING does not match with implementation");
    static_assert(0x08 == Node::DOCUMENT_POSITION_CONTAINS, "the value of Node_DOCUMENT_POSITION_CONTAINS does not match with implementation");
    static_assert(0x10 == Node::DOCUMENT_POSITION_CONTAINED_BY, "the value of Node_DOCUMENT_POSITION_CONTAINED_BY does not match with implementation");
    static_assert(0x20 == Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, "the value of Node_DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC does not match with implementation");

    // Custom toString template
    functionTemplate->Set(v8AtomicString(isolate, "toString"), V8PerIsolateData::from(isolate)->toStringTemplate());
}

v8::Local<v8::FunctionTemplate> V8Node::domTemplate(v8::Isolate* isolate)
{
    return V8DOMConfiguration::domClassTemplate(isolate, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), installV8NodeTemplate);
}

bool V8Node::hasInstance(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Local<v8::Object> V8Node::findInstanceInPrototypeChain(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

Node* V8Node::toImplWithTypeCheck(v8::Isolate* isolate, v8::Local<v8::Value> value)
{
    return hasInstance(value, isolate) ? toImpl(v8::Local<v8::Object>::Cast(value)) : 0;
}

void V8Node::refObject(ScriptWrappable* scriptWrappable)
{
#if !ENABLE(OILPAN)
    scriptWrappable->toImpl<Node>()->ref();
#endif
}

void V8Node::derefObject(ScriptWrappable* scriptWrappable)
{
#if !ENABLE(OILPAN)
    scriptWrappable->toImpl<Node>()->deref();
#endif
}

} // namespace blink
