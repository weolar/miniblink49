// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#include "config.h"
#include "V8Internals.h"

#include "bindings/core/v8/Dictionary.h"
#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/ScriptPromise.h"
#include "bindings/core/v8/ScriptState.h"
#include "bindings/core/v8/ScriptValue.h"
#include "bindings/core/v8/SerializedScriptValue.h"
#include "bindings/core/v8/SerializedScriptValueFactory.h"
#include "bindings/core/v8/V8Animation.h"
#include "bindings/core/v8/V8ArrayBuffer.h"
#include "bindings/core/v8/V8CSSStyleDeclaration.h"
#include "bindings/core/v8/V8ClientRect.h"
#include "bindings/core/v8/V8ClientRectList.h"
#include "bindings/core/v8/V8DOMConfiguration.h"
#include "bindings/core/v8/V8DOMPoint.h"
#include "bindings/core/v8/V8DictionaryTest.h"
#include "bindings/core/v8/V8Document.h"
#include "bindings/core/v8/V8DocumentFragment.h"
#include "bindings/core/v8/V8Element.h"
#include "bindings/core/v8/V8GCObservation.h"
#include "bindings/core/v8/V8HTMLElement.h"
#include "bindings/core/v8/V8HTMLMediaElement.h"
#include "bindings/core/v8/V8HTMLSelectElement.h"
#include "bindings/core/v8/V8HiddenValue.h"
#include "bindings/core/v8/V8InternalRuntimeFlags.h"
#include "bindings/core/v8/V8InternalSettings.h"
#include "bindings/core/v8/V8Iterator.h"
#include "bindings/core/v8/V8LayerRectList.h"
#include "bindings/core/v8/V8Location.h"
#include "bindings/core/v8/V8Node.h"
#include "bindings/core/v8/V8NodeList.h"
#include "bindings/core/v8/V8ObjectConstructor.h"
#include "bindings/core/v8/V8PluginPlaceholderOptions.h"
#include "bindings/core/v8/V8PrivateScriptTest.h"
#include "bindings/core/v8/V8Range.h"
#include "bindings/core/v8/V8ShadowRoot.h"
#include "bindings/core/v8/V8TypeConversions.h"
#include "bindings/core/v8/V8UnionTypesTest.h"
#include "bindings/core/v8/V8Window.h"
#include "bindings/modules/v8/V8CanvasRenderingContext2D.h"
#include "core/dom/ContextFeatures.h"
#include "core/dom/Document.h"
#include "core/dom/NameNodeList.h"
#include "core/dom/NodeList.h"
#include "core/dom/StaticNodeList.h"
#include "core/html/LabelsNodeList.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "platform/TraceEvent.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace blink {

// Suppress warning: global constructors, because struct WrapperTypeInfo is trivial
// and does not depend on another global objects.
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif
WrapperTypeInfo V8Internals::wrapperTypeInfo = { gin::kEmbedderBlink, V8Internals::domTemplate, V8Internals::refObject, V8Internals::derefObject, V8Internals::trace, 0, 0, V8Internals::preparePrototypeObject, V8Internals::installConditionallyEnabledProperties, "Internals", 0, WrapperTypeInfo::WrapperTypeObjectPrototype, WrapperTypeInfo::ObjectClassId, WrapperTypeInfo::NotInheritFromEventTarget, WrapperTypeInfo::Independent, WrapperTypeInfo::GarbageCollectedObject };
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic pop
#endif

// This static member must be declared by DEFINE_WRAPPERTYPEINFO in Internals.h.
// For details, see the comment of DEFINE_WRAPPERTYPEINFO in
// bindings/core/v8/ScriptWrappable.h.
const WrapperTypeInfo& Internals::s_wrapperTypeInfo = V8Internals::wrapperTypeInfo;

namespace InternalsV8Internal {

static void pagePopupWindowAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Internals* impl = V8Internals::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->pagePopupWindow()), impl);
}

static void pagePopupWindowAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    InternalsV8Internal::pagePopupWindowAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void settingsAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Internals* impl = V8Internals::toImpl(holder);
    RefPtrWillBeRawPtr<InternalSettings> cppValue(impl->settings());
    if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
        return;
    v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
    if (!v8Value.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "settings"), v8Value);
        v8SetReturnValue(info, v8Value);
    }
}

static void settingsAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    InternalsV8Internal::settingsAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void runtimeFlagsAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Internals* impl = V8Internals::toImpl(holder);
    RawPtr<InternalRuntimeFlags> cppValue(impl->runtimeFlags());
    if (cppValue && DOMDataStore::setReturnValue(info.GetReturnValue(), cppValue.get()))
        return;
    v8::Local<v8::Value> v8Value(toV8(cppValue.get(), holder, info.GetIsolate()));
    if (!v8Value.IsEmpty()) {
        V8HiddenValue::setHiddenValue(info.GetIsolate(), holder, v8AtomicString(info.GetIsolate(), "runtimeFlags"), v8Value);
        v8SetReturnValue(info, v8Value);
    }
}

static void runtimeFlagsAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    InternalsV8Internal::runtimeFlagsAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void workerThreadCountAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Internals* impl = V8Internals::toImpl(holder);
    v8SetReturnValueUnsigned(info, impl->workerThreadCount());
}

static void workerThreadCountAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    InternalsV8Internal::workerThreadCountAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void cursorUpdatePendingAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Internals* impl = V8Internals::toImpl(holder);
    v8SetReturnValueBool(info, impl->cursorUpdatePending());
}

static void cursorUpdatePendingAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    InternalsV8Internal::cursorUpdatePendingAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void unscopeableAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Internals* impl = V8Internals::toImpl(holder);
    v8SetReturnValueString(info, impl->unscopeableAttribute(), info.GetIsolate());
}

static void unscopeableAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMGetter");
    InternalsV8Internal::unscopeableAttributeAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void addressMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "address", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("address", "Internals", "parameter 1 is not of type 'Node'."));
            return;
        }
    }
    v8SetReturnValueString(info, impl->address(node), info.GetIsolate());
}

static void addressMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::addressMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void observeGCMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "observeGC", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    ScriptValue observed;
    {
        observed = ScriptValue(ScriptState::current(info.GetIsolate()), info[0]);
    }
    v8SetReturnValue(info, impl->observeGC(observed));
}

static void observeGCMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::observeGCMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void elementLayoutTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "elementLayoutTreeAsText", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    String result = impl->elementLayoutTreeAsText(element, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void elementLayoutTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::elementLayoutTreeAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isPreloadedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "isPreloaded", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    V8StringResource<> url;
    {
        url = info[0];
        if (!url.prepare())
            return;
    }
    v8SetReturnValueBool(info, impl->isPreloaded(url));
}

static void isPreloadedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::isPreloadedMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isPreloadedByMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "isPreloadedBy", "Internals", 2, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    V8StringResource<> url;
    Document* document;
    {
        url = info[0];
        if (!url.prepare())
            return;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isPreloadedBy", "Internals", "parameter 2 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValueBool(info, impl->isPreloadedBy(url, document));
}

static void isPreloadedByMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::isPreloadedByMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isLoadingFromMemoryCacheMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "isLoadingFromMemoryCache", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    V8StringResource<> url;
    {
        url = info[0];
        if (!url.prepare())
            return;
    }
    v8SetReturnValueBool(info, impl->isLoadingFromMemoryCache(url));
}

static void isLoadingFromMemoryCacheMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::isLoadingFromMemoryCacheMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isSharingStyleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "isSharingStyle", "Internals", 2, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element1;
    Element* element2;
    {
        element1 = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element1) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSharingStyle", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
        element2 = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!element2) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSharingStyle", "Internals", "parameter 2 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValueBool(info, impl->isSharingStyle(element1, element2));
}

static void isSharingStyleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::isSharingStyleMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void computedStyleIncludingVisitedInfoMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "computedStyleIncludingVisitedInfo", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("computedStyleIncludingVisitedInfo", "Internals", "parameter 1 is not of type 'Node'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->computedStyleIncludingVisitedInfo(node));
}

static void computedStyleIncludingVisitedInfoMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::computedStyleIncludingVisitedInfoMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void createUserAgentShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "createUserAgentShadowRoot", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* host;
    {
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("createUserAgentShadowRoot", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->createUserAgentShadowRoot(host));
}

static void createUserAgentShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::createUserAgentShadowRootMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "shadowRoot", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* host;
    {
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("shadowRoot", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->shadowRoot(host));
}

static void shadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::shadowRootMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void youngestShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "youngestShadowRoot", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* host;
    {
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("youngestShadowRoot", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->youngestShadowRoot(host));
}

static void youngestShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::youngestShadowRootMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void oldestShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "oldestShadowRoot", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* host;
    {
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("oldestShadowRoot", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->oldestShadowRoot(host));
}

static void oldestShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::oldestShadowRootMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void youngerShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "youngerShadowRoot", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* root;
    {
        root = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!root) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<ShadowRoot> result = impl->youngerShadowRoot(root, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void youngerShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::youngerShadowRootMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shadowRootTypeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "shadowRootType", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* root;
    {
        root = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!root) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    String result = impl->shadowRootType(root, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void shadowRootTypeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::shadowRootTypeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void hasShadowInsertionPointMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasShadowInsertionPoint", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* root;
    {
        root = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!root) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    bool result = impl->hasShadowInsertionPoint(root, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasShadowInsertionPointMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::hasShadowInsertionPointMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void hasContentElementMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasContentElement", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* root;
    {
        root = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!root) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    bool result = impl->hasContentElement(root, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasContentElementMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::hasContentElementMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void countElementShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "countElementShadow", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* Root;
    {
        Root = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!Root) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    unsigned result = impl->countElementShadow(Root, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void countElementShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::countElementShadowMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shadowPseudoIdMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "shadowPseudoId", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("shadowPseudoId", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValueString(info, impl->shadowPseudoId(element), info.GetIsolate());
}

static void shadowPseudoIdMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::shadowPseudoIdMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isValidContentSelectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isValidContentSelect", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* contentElement;
    {
        contentElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!contentElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    bool result = impl->isValidContentSelect(contentElement, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void isValidContentSelectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::isValidContentSelectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void treeScopeRootNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "treeScopeRootNode", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("treeScopeRootNode", "Internals", "parameter 1 is not of type 'Node'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->treeScopeRootNode(node));
}

static void treeScopeRootNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::treeScopeRootNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void parentTreeScopeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "parentTreeScope", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("parentTreeScope", "Internals", "parameter 1 is not of type 'Node'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->parentTreeScope(node));
}

static void parentTreeScopeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::parentTreeScopeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void hasSelectorForIdInShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasSelectorForIdInShadow", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* host;
    V8StringResource<> id;
    {
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        id = info[1];
        if (!id.prepare())
            return;
    }
    bool result = impl->hasSelectorForIdInShadow(host, id, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasSelectorForIdInShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::hasSelectorForIdInShadowMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void hasSelectorForClassInShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasSelectorForClassInShadow", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* host;
    V8StringResource<> className;
    {
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        className = info[1];
        if (!className.prepare())
            return;
    }
    bool result = impl->hasSelectorForClassInShadow(host, className, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasSelectorForClassInShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::hasSelectorForClassInShadowMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void hasSelectorForAttributeInShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasSelectorForAttributeInShadow", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* host;
    V8StringResource<> attributeName;
    {
        host = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!host) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        attributeName = info[1];
        if (!attributeName.prepare())
            return;
    }
    bool result = impl->hasSelectorForAttributeInShadow(host, attributeName, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void hasSelectorForAttributeInShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::hasSelectorForAttributeInShadowMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void compareTreeScopePositionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "compareTreeScopePosition", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* treeScope1;
    Node* treeScope2;
    {
        treeScope1 = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!treeScope1) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        treeScope2 = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!treeScope2) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    unsigned result = impl->compareTreeScopePosition(treeScope1, treeScope2, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void compareTreeScopePositionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::compareTreeScopePositionMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void updateStyleAndReturnAffectedElementCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "updateStyleAndReturnAffectedElementCount", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    unsigned result = impl->updateStyleAndReturnAffectedElementCount(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void updateStyleAndReturnAffectedElementCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::updateStyleAndReturnAffectedElementCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void needsLayoutCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "needsLayoutCount", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    unsigned result = impl->needsLayoutCount(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void needsLayoutCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::needsLayoutCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void hitTestCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hitTestCount", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    unsigned result = impl->hitTestCount(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void hitTestCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::hitTestCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void hitTestCacheHitsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hitTestCacheHits", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    unsigned result = impl->hitTestCacheHits(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void hitTestCacheHitsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::hitTestCacheHitsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void elementFromPointMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "elementFromPoint", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        setMinimumArityTypeError(exceptionState, 5, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    double x;
    double y;
    bool ignoreClipping;
    bool allowChildFrameContent;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        x = toRestrictedDouble(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toRestrictedDouble(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        ignoreClipping = toBoolean(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        allowChildFrameContent = toBoolean(info.GetIsolate(), info[4], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    RefPtrWillBeRawPtr<Element> result = impl->elementFromPoint(document, x, y, ignoreClipping, allowChildFrameContent, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void elementFromPointMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::elementFromPointMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void clearHitTestCacheMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "clearHitTestCache", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->clearHitTestCache(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void clearHitTestCacheMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::clearHitTestCacheMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void pauseAnimationsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "pauseAnimations", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    double pauseTime;
    {
        pauseTime = toRestrictedDouble(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->pauseAnimations(pauseTime, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void pauseAnimationsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::pauseAnimationsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isCompositedAnimationMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "isCompositedAnimation", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Animation* animation;
    {
        animation = V8Animation::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!animation) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isCompositedAnimation", "Internals", "parameter 1 is not of type 'Animation'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->isCompositedAnimation(animation));
}

static void isCompositedAnimationMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::isCompositedAnimationMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void advanceTimeForImageMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "advanceTimeForImage", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* image;
    double deltaTimeInSeconds;
    {
        image = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!image) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        deltaTimeInSeconds = toRestrictedDouble(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->advanceTimeForImage(image, deltaTimeInSeconds, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void advanceTimeForImageMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::advanceTimeForImageMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void nextSiblingInComposedTreeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "nextSiblingInComposedTree", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->nextSiblingInComposedTree(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void nextSiblingInComposedTreeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::nextSiblingInComposedTreeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void firstChildInComposedTreeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "firstChildInComposedTree", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->firstChildInComposedTree(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void firstChildInComposedTreeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::firstChildInComposedTreeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lastChildInComposedTreeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "lastChildInComposedTree", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->lastChildInComposedTree(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void lastChildInComposedTreeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::lastChildInComposedTreeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void nextInComposedTreeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "nextInComposedTree", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->nextInComposedTree(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void nextInComposedTreeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::nextInComposedTreeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void previousInComposedTreeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "previousInComposedTree", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->previousInComposedTree(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void previousInComposedTreeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::previousInComposedTreeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void visiblePlaceholderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "visiblePlaceholder", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("visiblePlaceholder", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValueString(info, impl->visiblePlaceholder(element), info.GetIsolate());
}

static void visiblePlaceholderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::visiblePlaceholderMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void selectColorInColorChooserMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "selectColorInColorChooser", "Internals", 2, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    V8StringResource<> colorValue;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("selectColorInColorChooser", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
        colorValue = info[1];
        if (!colorValue.prepare())
            return;
    }
    impl->selectColorInColorChooser(element, colorValue);
}

static void selectColorInColorChooserMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::selectColorInColorChooserMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void endColorChooserMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "endColorChooser", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("endColorChooser", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    impl->endColorChooser(element);
}

static void endColorChooserMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::endColorChooserMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void hasAutofocusRequestMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        if (UNLIKELY(info.Length() <= 0)) {
            v8SetReturnValueBool(info, impl->hasAutofocusRequest());
            return;
        }
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("hasAutofocusRequest", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValueBool(info, impl->hasAutofocusRequest(document));
}

static void hasAutofocusRequestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::hasAutofocusRequestMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void formControlStateOfHistoryItemMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "formControlStateOfHistoryItem", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    Vector<String> result = impl->formControlStateOfHistoryItem(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, toV8(result, info.Holder(), info.GetIsolate()));
}

static void formControlStateOfHistoryItemMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::formControlStateOfHistoryItemMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setFormControlStateOfHistoryItemMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setFormControlStateOfHistoryItem", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Vector<String> values;
    {
        values = toImplArray<Vector<String>>(info[0], 1, info.GetIsolate(), exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setFormControlStateOfHistoryItem(values, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setFormControlStateOfHistoryItemMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setFormControlStateOfHistoryItemMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void absoluteCaretBoundsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "absoluteCaretBounds", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    RawPtr<ClientRect> result = impl->absoluteCaretBounds(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void absoluteCaretBoundsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::absoluteCaretBoundsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void boundingBoxMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "boundingBox", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("boundingBox", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->boundingBox(element));
}

static void boundingBoxMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::boundingBoxMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void markerCountForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "markerCountForNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    V8StringResource<> markerType;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        markerType = info[1];
        if (!markerType.prepare())
            return;
    }
    unsigned result = impl->markerCountForNode(node, markerType, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueUnsigned(info, result);
}

static void markerCountForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::markerCountForNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void activeMarkerCountForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "activeMarkerCountForNode", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("activeMarkerCountForNode", "Internals", "parameter 1 is not of type 'Node'."));
            return;
        }
    }
    v8SetReturnValueUnsigned(info, impl->activeMarkerCountForNode(node));
}

static void activeMarkerCountForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::activeMarkerCountForNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void markerRangeForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "markerRangeForNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    V8StringResource<> markerType;
    unsigned index;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        markerType = info[1];
        if (!markerType.prepare())
            return;
        index = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    RefPtrWillBeRawPtr<Range> result = impl->markerRangeForNode(node, markerType, index, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void markerRangeForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::markerRangeForNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void markerDescriptionForNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "markerDescriptionForNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    V8StringResource<> markerType;
    unsigned index;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        markerType = info[1];
        if (!markerType.prepare())
            return;
        index = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    String result = impl->markerDescriptionForNode(node, markerType, index, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void markerDescriptionForNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::markerDescriptionForNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void addTextMatchMarkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "addTextMatchMarker", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Range* range;
    bool isActive;
    {
        range = V8Range::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!range) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Range'.");
            exceptionState.throwIfNeeded();
            return;
        }
        isActive = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->addTextMatchMarker(range, isActive);
}

static void addTextMatchMarkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::addTextMatchMarkerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setMarkersActiveMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setMarkersActive", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        setMinimumArityTypeError(exceptionState, 4, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    unsigned startOffset;
    unsigned endOffset;
    bool active;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        startOffset = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        endOffset = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        active = toBoolean(info.GetIsolate(), info[3], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setMarkersActive(node, startOffset, endOffset, active);
}

static void setMarkersActiveMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setMarkersActiveMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setMarkedTextMatchesAreHighlightedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setMarkedTextMatchesAreHighlighted", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    bool highlight;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        highlight = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setMarkedTextMatchesAreHighlighted(document, highlight);
}

static void setMarkedTextMatchesAreHighlightedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setMarkedTextMatchesAreHighlightedMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setFrameViewPositionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setFrameViewPosition", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    int x;
    int y;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setFrameViewPosition(document, x, y, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setFrameViewPositionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setFrameViewPositionMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void viewportAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "viewportAsText", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        setMinimumArityTypeError(exceptionState, 4, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    float devicePixelRatio;
    int availableWidth;
    int availableHeight;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        devicePixelRatio = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        availableWidth = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        availableHeight = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    String result = impl->viewportAsText(document, devicePixelRatio, availableWidth, availableHeight, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void viewportAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::viewportAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void wasLastChangeUserEditMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "wasLastChangeUserEdit", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* textField;
    {
        textField = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!textField) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    bool result = impl->wasLastChangeUserEdit(textField, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void wasLastChangeUserEditMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::wasLastChangeUserEditMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void elementShouldAutoCompleteMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "elementShouldAutoComplete", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* inputElement;
    {
        inputElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!inputElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    bool result = impl->elementShouldAutoComplete(inputElement, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void elementShouldAutoCompleteMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::elementShouldAutoCompleteMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void suggestedValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "suggestedValue", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* inputElement;
    {
        inputElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!inputElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    String result = impl->suggestedValue(inputElement, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void suggestedValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::suggestedValueMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setSuggestedValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setSuggestedValue", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* inputElement;
    V8StringResource<> value;
    {
        inputElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!inputElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        value = info[1];
        if (!value.prepare())
            return;
    }
    impl->setSuggestedValue(inputElement, value, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setSuggestedValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setSuggestedValueMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setEditingValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setEditingValue", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* inputElement;
    V8StringResource<> value;
    {
        inputElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!inputElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        value = info[1];
        if (!value.prepare())
            return;
    }
    impl->setEditingValue(inputElement, value, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setEditingValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setEditingValueMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setAutofilledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setAutofilled", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* inputElement;
    bool enabled;
    {
        inputElement = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!inputElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        enabled = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setAutofilled(inputElement, enabled, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setAutofilledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setAutofilledMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void scrollElementToRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollElementToRect", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        setMinimumArityTypeError(exceptionState, 5, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    int x;
    int y;
    int w;
    int h;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        w = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        h = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->scrollElementToRect(element, x, y, w, h, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void scrollElementToRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::scrollElementToRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void rangeFromLocationAndLengthMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "rangeFromLocationAndLength", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* scope;
    int rangeLocation;
    int rangeLength;
    {
        scope = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!scope) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        rangeLocation = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        rangeLength = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValue(info, impl->rangeFromLocationAndLength(scope, rangeLocation, rangeLength));
}

static void rangeFromLocationAndLengthMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::rangeFromLocationAndLengthMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void locationFromRangeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "locationFromRange", "Internals", 2, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* scope;
    Range* range;
    {
        scope = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!scope) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("locationFromRange", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
        range = V8Range::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!range) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("locationFromRange", "Internals", "parameter 2 is not of type 'Range'."));
            return;
        }
    }
    v8SetReturnValueUnsigned(info, impl->locationFromRange(scope, range));
}

static void locationFromRangeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::locationFromRangeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lengthFromRangeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "lengthFromRange", "Internals", 2, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* scope;
    Range* range;
    {
        scope = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!scope) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("lengthFromRange", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
        range = V8Range::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!range) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("lengthFromRange", "Internals", "parameter 2 is not of type 'Range'."));
            return;
        }
    }
    v8SetReturnValueUnsigned(info, impl->lengthFromRange(scope, range));
}

static void lengthFromRangeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::lengthFromRangeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void rangeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "rangeAsText", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Range* range;
    {
        range = V8Range::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!range) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("rangeAsText", "Internals", "parameter 1 is not of type 'Range'."));
            return;
        }
    }
    v8SetReturnValueString(info, impl->rangeAsText(range), info.GetIsolate());
}

static void rangeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::rangeAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void touchPositionAdjustedToBestClickableNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "touchPositionAdjustedToBestClickableNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        setMinimumArityTypeError(exceptionState, 5, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    int x;
    int y;
    int width;
    int height;
    Document* document;
    {
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[4]);
        if (!document) {
            exceptionState.throwTypeError("parameter 5 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RawPtr<DOMPoint> result = impl->touchPositionAdjustedToBestClickableNode(x, y, width, height, document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void touchPositionAdjustedToBestClickableNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::touchPositionAdjustedToBestClickableNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void touchNodeAdjustedToBestClickableNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "touchNodeAdjustedToBestClickableNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        setMinimumArityTypeError(exceptionState, 5, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    int x;
    int y;
    int width;
    int height;
    Document* document;
    {
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[4]);
        if (!document) {
            exceptionState.throwTypeError("parameter 5 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->touchNodeAdjustedToBestClickableNode(x, y, width, height, document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void touchNodeAdjustedToBestClickableNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::touchNodeAdjustedToBestClickableNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void touchPositionAdjustedToBestContextMenuNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "touchPositionAdjustedToBestContextMenuNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        setMinimumArityTypeError(exceptionState, 5, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    int x;
    int y;
    int width;
    int height;
    Document* document;
    {
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[4]);
        if (!document) {
            exceptionState.throwTypeError("parameter 5 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RawPtr<DOMPoint> result = impl->touchPositionAdjustedToBestContextMenuNode(x, y, width, height, document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void touchPositionAdjustedToBestContextMenuNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::touchPositionAdjustedToBestContextMenuNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void touchNodeAdjustedToBestContextMenuNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "touchNodeAdjustedToBestContextMenuNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        setMinimumArityTypeError(exceptionState, 5, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    int x;
    int y;
    int width;
    int height;
    Document* document;
    {
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[4]);
        if (!document) {
            exceptionState.throwTypeError("parameter 5 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RefPtrWillBeRawPtr<Node> result = impl->touchNodeAdjustedToBestContextMenuNode(x, y, width, height, document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void touchNodeAdjustedToBestContextMenuNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::touchNodeAdjustedToBestContextMenuNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void bestZoomableAreaForTouchPointMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "bestZoomableAreaForTouchPoint", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 5)) {
        setMinimumArityTypeError(exceptionState, 5, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    int x;
    int y;
    int width;
    int height;
    Document* document;
    {
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        width = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        height = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[4]);
        if (!document) {
            exceptionState.throwTypeError("parameter 5 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RawPtr<ClientRect> result = impl->bestZoomableAreaForTouchPoint(x, y, width, height, document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void bestZoomableAreaForTouchPointMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::bestZoomableAreaForTouchPointMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lastSpellCheckRequestSequenceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "lastSpellCheckRequestSequence", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    int result = impl->lastSpellCheckRequestSequence(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueInt(info, result);
}

static void lastSpellCheckRequestSequenceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::lastSpellCheckRequestSequenceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void lastSpellCheckProcessedSequenceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "lastSpellCheckProcessedSequence", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    int result = impl->lastSpellCheckProcessedSequence(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueInt(info, result);
}

static void lastSpellCheckProcessedSequenceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::lastSpellCheckProcessedSequenceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void userPreferredLanguagesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValue(info, toV8(impl->userPreferredLanguages(), info.Holder(), info.GetIsolate()));
}

static void userPreferredLanguagesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::userPreferredLanguagesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setUserPreferredLanguagesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setUserPreferredLanguages", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Vector<String> languages;
    {
        languages = toImplArray<Vector<String>>(info[0], 1, info.GetIsolate(), exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setUserPreferredLanguages(languages);
}

static void setUserPreferredLanguagesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setUserPreferredLanguagesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void activeDOMObjectCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "activeDOMObjectCount", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("activeDOMObjectCount", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValueUnsigned(info, impl->activeDOMObjectCount(document));
}

static void activeDOMObjectCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::activeDOMObjectCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void wheelEventHandlerCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "wheelEventHandlerCount", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("wheelEventHandlerCount", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValueUnsigned(info, impl->wheelEventHandlerCount(document));
}

static void wheelEventHandlerCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::wheelEventHandlerCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void scrollEventHandlerCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "scrollEventHandlerCount", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("scrollEventHandlerCount", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValueUnsigned(info, impl->scrollEventHandlerCount(document));
}

static void scrollEventHandlerCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::scrollEventHandlerCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void touchEventHandlerCountMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "touchEventHandlerCount", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("touchEventHandlerCount", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValueUnsigned(info, impl->touchEventHandlerCount(document));
}

static void touchEventHandlerCountMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::touchEventHandlerCountMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void touchEventTargetLayerRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "touchEventTargetLayerRects", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RawPtr<LayerRectList> result = impl->touchEventTargetLayerRects(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void touchEventTargetLayerRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::touchEventTargetLayerRectsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void executeCommandMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "executeCommand", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    V8StringResource<> name;
    V8StringResource<> value;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        name = info[1];
        if (!name.prepare())
            return;
        value = info[2];
        if (!value.prepare())
            return;
    }
    bool result = impl->executeCommand(document, name, value, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void executeCommandMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::executeCommandMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void htmlNamespaceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValueString(info, impl->htmlNamespace(), info.GetIsolate());
}

static void htmlNamespaceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::htmlNamespaceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void htmlTagsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValue(info, toV8(impl->htmlTags(), info.Holder(), info.GetIsolate()));
}

static void htmlTagsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::htmlTagsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void svgNamespaceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValueString(info, impl->svgNamespace(), info.GetIsolate());
}

static void svgNamespaceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::svgNamespaceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void svgTagsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValue(info, toV8(impl->svgTags(), info.Holder(), info.GetIsolate()));
}

static void svgTagsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::svgTagsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void nodesFromRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "nodesFromRect", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 9)) {
        setMinimumArityTypeError(exceptionState, 9, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    int x;
    int y;
    unsigned topPadding;
    unsigned rightPadding;
    unsigned bottomPadding;
    unsigned leftPadding;
    bool ignoreClipping;
    bool allowChildFrameContent;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        topPadding = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        rightPadding = toUInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        bottomPadding = toUInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        leftPadding = toUInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        ignoreClipping = toBoolean(info.GetIsolate(), info[7], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        allowChildFrameContent = toBoolean(info.GetIsolate(), info[8], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    RefPtrWillBeRawPtr<NodeList> result = impl->nodesFromRect(document, x, y, topPadding, rightPadding, bottomPadding, leftPadding, ignoreClipping, allowChildFrameContent, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void nodesFromRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::nodesFromRectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void hasSpellingMarkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasSpellingMarker", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    int from;
    int length;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        from = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        length = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueBool(info, impl->hasSpellingMarker(document, from, length));
}

static void hasSpellingMarkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::hasSpellingMarkerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void hasGrammarMarkerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasGrammarMarker", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    int from;
    int length;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        from = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        length = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueBool(info, impl->hasGrammarMarker(document, from, length));
}

static void hasGrammarMarkerMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::hasGrammarMarkerMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setContinuousSpellCheckingEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setContinuousSpellCheckingEnabled", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    bool enabled;
    {
        enabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setContinuousSpellCheckingEnabled(enabled);
}

static void setContinuousSpellCheckingEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setContinuousSpellCheckingEnabledMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isOverwriteModeEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "isOverwriteModeEnabled", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isOverwriteModeEnabled", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValueBool(info, impl->isOverwriteModeEnabled(document));
}

static void isOverwriteModeEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::isOverwriteModeEnabledMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void toggleOverwriteModeEnabledMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "toggleOverwriteModeEnabled", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("toggleOverwriteModeEnabled", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    impl->toggleOverwriteModeEnabled(document);
}

static void toggleOverwriteModeEnabledMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::toggleOverwriteModeEnabledMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void numberOfScrollableAreasMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "numberOfScrollableAreas", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("numberOfScrollableAreas", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValueUnsigned(info, impl->numberOfScrollableAreas(document));
}

static void numberOfScrollableAreasMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::numberOfScrollableAreasMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isPageBoxVisibleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isPageBoxVisible", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    int pageNumber;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        pageNumber = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueBool(info, impl->isPageBoxVisible(document, pageNumber));
}

static void isPageBoxVisibleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::isPageBoxVisibleMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void layerTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "layerTreeAsText", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    unsigned flags;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        if (UNLIKELY(info.Length() <= 1)) {
            String result = impl->layerTreeAsText(document, exceptionState);
            if (exceptionState.hadException()) {
                exceptionState.throwIfNeeded();
                return;
            }
            v8SetReturnValueString(info, result, info.GetIsolate());
            return;
        }
        flags = toUInt16(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    String result = impl->layerTreeAsText(document, flags, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void layerTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::layerTreeAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void elementLayerTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "elementLayerTreeAsText", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    unsigned flags;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        if (UNLIKELY(info.Length() <= 1)) {
            String result = impl->elementLayerTreeAsText(element, exceptionState);
            if (exceptionState.hadException()) {
                exceptionState.throwIfNeeded();
                return;
            }
            v8SetReturnValueString(info, result, info.GetIsolate());
            return;
        }
        flags = toUInt16(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    String result = impl->elementLayerTreeAsText(element, flags, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void elementLayerTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::elementLayerTreeAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void scrollsWithRespectToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollsWithRespectTo", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element1;
    Element* element2;
    {
        element1 = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element1) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        element2 = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!element2) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    bool result = impl->scrollsWithRespectTo(element1, element2, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void scrollsWithRespectToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::scrollsWithRespectToMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void scrollingStateTreeAsTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "scrollingStateTreeAsText", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("scrollingStateTreeAsText", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValueString(info, impl->scrollingStateTreeAsText(document), info.GetIsolate());
}

static void scrollingStateTreeAsTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::scrollingStateTreeAsTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void mainThreadScrollingReasonsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "mainThreadScrollingReasons", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    String result = impl->mainThreadScrollingReasons(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void mainThreadScrollingReasonsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::mainThreadScrollingReasonsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void nonFastScrollableRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "nonFastScrollableRects", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RawPtr<ClientRectList> result = impl->nonFastScrollableRects(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void nonFastScrollableRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::nonFastScrollableRectsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void garbageCollectDocumentResourcesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "garbageCollectDocumentResources", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("garbageCollectDocumentResources", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    impl->garbageCollectDocumentResources(document);
}

static void garbageCollectDocumentResourcesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::garbageCollectDocumentResourcesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void evictAllResourcesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    impl->evictAllResources();
}

static void evictAllResourcesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::evictAllResourcesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void numberOfLiveNodesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValueUnsigned(info, impl->numberOfLiveNodes());
}

static void numberOfLiveNodesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::numberOfLiveNodesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void numberOfLiveDocumentsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValueUnsigned(info, impl->numberOfLiveDocuments());
}

static void numberOfLiveDocumentsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::numberOfLiveDocumentsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void dumpRefCountedInstanceCountsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValueString(info, impl->dumpRefCountedInstanceCounts(), info.GetIsolate());
}

static void dumpRefCountedInstanceCountsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::dumpRefCountedInstanceCountsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void consoleMessageArgumentCountsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "consoleMessageArgumentCounts", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("consoleMessageArgumentCounts", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValue(info, toV8(impl->consoleMessageArgumentCounts(document), info.Holder(), info.GetIsolate()));
}

static void consoleMessageArgumentCountsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::consoleMessageArgumentCountsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setMemoryCacheCapacitiesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setMemoryCacheCapacities", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    unsigned minDeadBytes;
    unsigned maxDeadBytes;
    unsigned totalBytes;
    {
        minDeadBytes = toUInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        maxDeadBytes = toUInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        totalBytes = toUInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValue(info, toV8(impl->setMemoryCacheCapacities(minDeadBytes, maxDeadBytes, totalBytes), info.Holder(), info.GetIsolate()));
}

static void setMemoryCacheCapacitiesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setMemoryCacheCapacitiesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void counterValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "counterValue", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("counterValue", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValueString(info, impl->counterValue(element), info.GetIsolate());
}

static void counterValueMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::counterValueMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void pageNumberMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "pageNumber", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    float pageWidth;
    float pageHeight;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        if (UNLIKELY(info.Length() <= 1)) {
            v8SetReturnValueInt(info, impl->pageNumber(element));
            return;
        }
        pageWidth = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        if (UNLIKELY(info.Length() <= 2)) {
            v8SetReturnValueInt(info, impl->pageNumber(element, pageWidth));
            return;
        }
        pageHeight = toRestrictedFloat(info.GetIsolate(), info[2], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueInt(info, impl->pageNumber(element, pageWidth, pageHeight));
}

static void pageNumberMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::pageNumberMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void shortcutIconURLsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "shortcutIconURLs", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("shortcutIconURLs", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValue(info, toV8(impl->shortcutIconURLs(document), info.Holder(), info.GetIsolate()));
}

static void shortcutIconURLsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::shortcutIconURLsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void allIconURLsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "allIconURLs", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("allIconURLs", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValue(info, toV8(impl->allIconURLs(document), info.Holder(), info.GetIsolate()));
}

static void allIconURLsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::allIconURLsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void numberOfPagesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "numberOfPages", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    double pageWidthInPixels;
    double pageHeightInPixels;
    {
        if (UNLIKELY(info.Length() <= 0)) {
            v8SetReturnValueInt(info, impl->numberOfPages());
            return;
        }
        pageWidthInPixels = toRestrictedDouble(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        if (UNLIKELY(info.Length() <= 1)) {
            v8SetReturnValueInt(info, impl->numberOfPages(pageWidthInPixels));
            return;
        }
        pageHeightInPixels = toRestrictedDouble(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueInt(info, impl->numberOfPages(pageWidthInPixels, pageHeightInPixels));
}

static void numberOfPagesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::numberOfPagesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void pagePropertyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "pageProperty", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    V8StringResource<> propertyName;
    int pageNumber;
    {
        propertyName = info[0];
        if (!propertyName.prepare())
            return;
        pageNumber = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    String result = impl->pageProperty(propertyName, pageNumber, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void pagePropertyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::pagePropertyMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void pageSizeAndMarginsInPixelsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "pageSizeAndMarginsInPixels", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 7)) {
        setMinimumArityTypeError(exceptionState, 7, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    int pageIndex;
    int width;
    int height;
    int marginTop;
    int marginRight;
    int marginBottom;
    int marginLeft;
    {
        pageIndex = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        width = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        height = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        marginTop = toInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        marginRight = toInt32(info.GetIsolate(), info[4], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        marginBottom = toInt32(info.GetIsolate(), info[5], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        marginLeft = toInt32(info.GetIsolate(), info[6], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    String result = impl->pageSizeAndMarginsInPixels(pageIndex, width, height, marginTop, marginRight, marginBottom, marginLeft, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueString(info, result, info.GetIsolate());
}

static void pageSizeAndMarginsInPixelsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::pageSizeAndMarginsInPixelsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setDeviceScaleFactorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setDeviceScaleFactor", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    float scaleFactor;
    {
        scaleFactor = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setDeviceScaleFactor(scaleFactor, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setDeviceScaleFactorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setDeviceScaleFactorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setPageScaleFactorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setPageScaleFactor", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    float scaleFactor;
    {
        scaleFactor = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setPageScaleFactor(scaleFactor, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setPageScaleFactorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setPageScaleFactorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setPageScaleFactorLimitsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setPageScaleFactorLimits", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    float minScaleFactor;
    float maxScaleFactor;
    {
        minScaleFactor = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        maxScaleFactor = toRestrictedFloat(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setPageScaleFactorLimits(minScaleFactor, maxScaleFactor, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setPageScaleFactorLimitsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setPageScaleFactorLimitsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setIsCursorVisibleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setIsCursorVisible", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    bool isVisible;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        isVisible = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setIsCursorVisible(document, isVisible, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setIsCursorVisibleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setIsCursorVisibleMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void effectiveMediaVolumeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "effectiveMediaVolume", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    HTMLMediaElement* mediaElement;
    {
        mediaElement = V8HTMLMediaElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!mediaElement) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("effectiveMediaVolume", "Internals", "parameter 1 is not of type 'HTMLMediaElement'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->effectiveMediaVolume(mediaElement));
}

static void effectiveMediaVolumeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::effectiveMediaVolumeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void mediaPlayerRemoteRouteAvailabilityChangedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "mediaPlayerRemoteRouteAvailabilityChanged", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    HTMLMediaElement* mediaElement;
    bool available;
    {
        mediaElement = V8HTMLMediaElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!mediaElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLMediaElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        available = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->mediaPlayerRemoteRouteAvailabilityChanged(mediaElement, available);
}

static void mediaPlayerRemoteRouteAvailabilityChangedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::mediaPlayerRemoteRouteAvailabilityChangedMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void mediaPlayerPlayingRemotelyChangedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "mediaPlayerPlayingRemotelyChanged", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    HTMLMediaElement* mediaElement;
    bool remote;
    {
        mediaElement = V8HTMLMediaElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!mediaElement) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLMediaElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        remote = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->mediaPlayerPlayingRemotelyChanged(mediaElement, remote);
}

static void mediaPlayerPlayingRemotelyChangedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::mediaPlayerPlayingRemotelyChangedMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void registerURLSchemeAsBypassingContentSecurityPolicy1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    V8StringResource<> scheme;
    {
        scheme = info[0];
        if (!scheme.prepare())
            return;
    }
    impl->registerURLSchemeAsBypassingContentSecurityPolicy(scheme);
}

static void registerURLSchemeAsBypassingContentSecurityPolicy2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "registerURLSchemeAsBypassingContentSecurityPolicy", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    V8StringResource<> scheme;
    Vector<String> policyAreas;
    {
        scheme = info[0];
        if (!scheme.prepare())
            return;
        policyAreas = toImplArray<Vector<String>>(info[1], 2, info.GetIsolate(), exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->registerURLSchemeAsBypassingContentSecurityPolicy(scheme, policyAreas);
}

static void registerURLSchemeAsBypassingContentSecurityPolicyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "registerURLSchemeAsBypassingContentSecurityPolicy", "Internals", info.Holder(), info.GetIsolate());
    switch (std::min(2, info.Length())) {
    case 1:
        if (true) {
            registerURLSchemeAsBypassingContentSecurityPolicy1Method(info);
            return;
        }
        break;
    case 2:
        if (true) {
            registerURLSchemeAsBypassingContentSecurityPolicy2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    if (info.Length() < 1) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void registerURLSchemeAsBypassingContentSecurityPolicyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::registerURLSchemeAsBypassingContentSecurityPolicyMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "removeURLSchemeRegisteredAsBypassingContentSecurityPolicy", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    V8StringResource<> scheme;
    {
        scheme = info[0];
        if (!scheme.prepare())
            return;
    }
    impl->removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(scheme);
}

static void removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void typeConversionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValue(info, impl->typeConversions());
}

static void typeConversionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::typeConversionsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void privateScriptTestMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValue(info, impl->privateScriptTest());
}

static void privateScriptTestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::privateScriptTestMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void getReferencedFilePathsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValue(info, toV8(impl->getReferencedFilePaths(), info.Holder(), info.GetIsolate()));
}

static void getReferencedFilePathsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::getReferencedFilePathsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void startTrackingRepaintsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "startTrackingRepaints", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->startTrackingRepaints(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void startTrackingRepaintsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::startTrackingRepaintsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void stopTrackingRepaintsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "stopTrackingRepaints", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->stopTrackingRepaints(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void stopTrackingRepaintsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::stopTrackingRepaintsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        if (!info[0]->IsUndefined()) {
            node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
            if (!node && !isUndefinedOrNull(info[0])) {
                exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
                exceptionState.throwIfNeeded();
                return;
            }
        } else {
            node = nullptr;
        }
    }
    impl->updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks(node, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void forceFullRepaintMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "forceFullRepaint", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->forceFullRepaint(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void forceFullRepaintMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::forceFullRepaintMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void draggableRegionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "draggableRegions", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RawPtr<ClientRectList> result = impl->draggableRegions(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void draggableRegionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::draggableRegionsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void nonDraggableRegionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "nonDraggableRegions", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    RawPtr<ClientRectList> result = impl->nonDraggableRegions(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void nonDraggableRegionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::nonDraggableRegionsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void getCurrentCursorInfoMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValueString(info, impl->getCurrentCursorInfo(), info.GetIsolate());
}

static void getCurrentCursorInfoMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::getCurrentCursorInfoMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void markerTextForListItemMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "markerTextForListItem", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("markerTextForListItem", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValueString(info, impl->markerTextForListItem(element), info.GetIsolate());
}

static void markerTextForListItemMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::markerTextForListItemMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void deserializeBufferMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "deserializeBuffer", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    DOMArrayBuffer* buffer;
    {
        buffer = info[0]->IsArrayBuffer() ? V8ArrayBuffer::toImpl(v8::Local<v8::ArrayBuffer>::Cast(info[0])) : 0;
        if (!buffer) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("deserializeBuffer", "Internals", "parameter 1 is not of type 'ArrayBuffer'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->deserializeBuffer(buffer) ? impl->deserializeBuffer(buffer)->deserialize() : v8::Local<v8::Value>(v8::Null(info.GetIsolate())));
}

static void deserializeBufferMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::deserializeBufferMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void serializeObjectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "serializeObject", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    RefPtr<SerializedScriptValue> obj;
    {
        obj = SerializedScriptValueFactory::instance().create(info.GetIsolate(), info[0], 0, 0, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValue(info, impl->serializeObject(obj));
}

static void serializeObjectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::serializeObjectMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void forceReloadMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "forceReload", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    bool endToEnd;
    {
        endToEnd = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->forceReload(endToEnd);
}

static void forceReloadMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::forceReloadMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void getImageSourceURLMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "getImageSourceURL", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("getImageSourceURL", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValueString(info, impl->getImageSourceURL(element), info.GetIsolate());
}

static void getImageSourceURLMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::getImageSourceURLMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void selectMenuListTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "selectMenuListText", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    HTMLSelectElement* select;
    {
        select = V8HTMLSelectElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!select) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("selectMenuListText", "Internals", "parameter 1 is not of type 'HTMLSelectElement'."));
            return;
        }
    }
    v8SetReturnValueString(info, impl->selectMenuListText(select), info.GetIsolate());
}

static void selectMenuListTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::selectMenuListTextMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isSelectPopupVisibleMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "isSelectPopupVisible", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isSelectPopupVisible", "Internals", "parameter 1 is not of type 'Node'."));
            return;
        }
    }
    v8SetReturnValueBool(info, impl->isSelectPopupVisible(node));
}

static void isSelectPopupVisibleMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::isSelectPopupVisibleMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void selectPopupItemStyleIsRtlMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "selectPopupItemStyleIsRtl", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* select;
    int itemIndex;
    {
        select = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!select) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        itemIndex = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueBool(info, impl->selectPopupItemStyleIsRtl(select, itemIndex));
}

static void selectPopupItemStyleIsRtlMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::selectPopupItemStyleIsRtlMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void selectPopupItemStyleFontHeightMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "selectPopupItemStyleFontHeight", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* select;
    int itemIndex;
    {
        select = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!select) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        itemIndex = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueInt(info, impl->selectPopupItemStyleFontHeight(select, itemIndex));
}

static void selectPopupItemStyleFontHeightMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::selectPopupItemStyleFontHeightMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void selectionBoundsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "selectionBounds", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    RawPtr<ClientRect> result = impl->selectionBounds(exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void selectionBoundsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::selectionBoundsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void loseSharedGraphicsContext3DMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValueBool(info, impl->loseSharedGraphicsContext3D());
}

static void loseSharedGraphicsContext3DMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::loseSharedGraphicsContext3DMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void forceCompositingUpdateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "forceCompositingUpdate", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->forceCompositingUpdate(document, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void forceCompositingUpdateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::forceCompositingUpdateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setZoomFactorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setZoomFactor", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    float factor;
    {
        factor = toRestrictedFloat(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setZoomFactor(factor);
}

static void setZoomFactorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setZoomFactorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setShouldRevealPasswordMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setShouldRevealPassword", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    bool reveal;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
        reveal = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setShouldRevealPassword(element, reveal, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setShouldRevealPasswordMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setShouldRevealPasswordMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void createResolvedPromiseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        v8SetReturnValue(info, ScriptPromise::rejectRaw(ScriptState::current(info.GetIsolate()), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "createResolvedPromise", "Internals", 1, info.Length())));
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    ScriptValue value;
    {
        value = ScriptValue(ScriptState::current(info.GetIsolate()), info[0]);
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->createResolvedPromise(scriptState, value);
    v8SetReturnValue(info, result.v8Value());
}

static void createResolvedPromiseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::createResolvedPromiseMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void createRejectedPromiseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        v8SetReturnValue(info, ScriptPromise::rejectRaw(ScriptState::current(info.GetIsolate()), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "createRejectedPromise", "Internals", 1, info.Length())));
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    ScriptValue reason;
    {
        reason = ScriptValue(ScriptState::current(info.GetIsolate()), info[0]);
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->createRejectedPromise(scriptState, reason);
    v8SetReturnValue(info, result.v8Value());
}

static void createRejectedPromiseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::createRejectedPromiseMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void addOneToPromiseMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        v8SetReturnValue(info, ScriptPromise::rejectRaw(ScriptState::current(info.GetIsolate()), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "addOneToPromise", "Internals", 1, info.Length())));
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    ScriptPromise promise;
    {
        promise = ScriptPromise::cast(ScriptState::current(info.GetIsolate()), info[0]);
        if (!promise.isUndefinedOrNull() && !promise.isObject()) {
            v8SetReturnValue(info, ScriptPromise::rejectRaw(ScriptState::current(info.GetIsolate()), V8ThrowException::createTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("addOneToPromise", "Internals", "parameter 1 ('promise') is not an object."))));
            return;
        }
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->addOneToPromise(scriptState, promise);
    v8SetReturnValue(info, result.v8Value());
}

static void addOneToPromiseMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::addOneToPromiseMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void promiseCheckMethodPromise(const v8::FunctionCallbackInfo<v8::Value>& info, ExceptionState& exceptionState)
{
    if (UNLIKELY(info.Length() < 5)) {
        setMinimumArityTypeError(exceptionState, 5, info.Length());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    int arg1;
    bool arg2;
    Dictionary arg3;
    V8StringResource<> arg4;
    Vector<String> arg5;
    {
        arg1 = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;
        arg2 = toBoolean(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.hadException())
            return;
        if (!isUndefinedOrNull(info[2]) && !info[2]->IsObject()) {
            exceptionState.throwTypeError("parameter 3 ('arg3') is not an object.");
            return;
        }
        arg3 = Dictionary(info[2], info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;
        arg4 = info[3];
        if (!arg4.prepare(exceptionState))
            return;
        arg5 = toImplArray<Vector<String>>(info[4], 5, info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->promiseCheck(scriptState, arg1, arg2, arg3, arg4, arg5, exceptionState);
    if (exceptionState.hadException()) {
        return;
    }
    v8SetReturnValue(info, result.v8Value());
}

static void promiseCheckMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "promiseCheck", "Internals", info.Holder(), info.GetIsolate());
    promiseCheckMethodPromise(info, exceptionState);
    if (exceptionState.hadException())
        v8SetReturnValue(info, exceptionState.reject(ScriptState::current(info.GetIsolate())).v8Value());
}

static void promiseCheckMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::promiseCheckMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void promiseCheckWithoutExceptionStateMethodPromise(const v8::FunctionCallbackInfo<v8::Value>& info, ExceptionState& exceptionState)
{
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Dictionary arg1;
    V8StringResource<> arg2;
    Vector<String> variadic;
    {
        if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
            exceptionState.throwTypeError("parameter 1 ('arg1') is not an object.");
            return;
        }
        arg1 = Dictionary(info[0], info.GetIsolate(), exceptionState);
        if (exceptionState.hadException())
            return;
        arg2 = info[1];
        if (!arg2.prepare(exceptionState))
            return;
        variadic = toImplArguments<Vector<String>>(info, 2, exceptionState);
        if (exceptionState.hadException())
            return;
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->promiseCheckWithoutExceptionState(scriptState, arg1, arg2, variadic);
    v8SetReturnValue(info, result.v8Value());
}

static void promiseCheckWithoutExceptionStateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "promiseCheckWithoutExceptionState", "Internals", info.Holder(), info.GetIsolate());
    promiseCheckWithoutExceptionStateMethodPromise(info, exceptionState);
    if (exceptionState.hadException())
        v8SetReturnValue(info, exceptionState.reject(ScriptState::current(info.GetIsolate())).v8Value());
}

static void promiseCheckWithoutExceptionStateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::promiseCheckWithoutExceptionStateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void promiseCheckRangeMethodPromise(const v8::FunctionCallbackInfo<v8::Value>& info, ExceptionState& exceptionState)
{
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    unsigned arg1;
    {
        arg1 = toUInt8(info.GetIsolate(), info[0], EnforceRange, exceptionState);
        if (exceptionState.hadException())
            return;
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->promiseCheckRange(scriptState, arg1);
    v8SetReturnValue(info, result.v8Value());
}

static void promiseCheckRangeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "promiseCheckRange", "Internals", info.Holder(), info.GetIsolate());
    promiseCheckRangeMethodPromise(info, exceptionState);
    if (exceptionState.hadException())
        v8SetReturnValue(info, exceptionState.reject(ScriptState::current(info.GetIsolate())).v8Value());
}

static void promiseCheckRangeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::promiseCheckRangeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void promiseCheckOverload1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    Location* arg1;
    {
        arg1 = V8Location::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!arg1) {
            v8SetReturnValue(info, ScriptPromise::rejectRaw(ScriptState::current(info.GetIsolate()), V8ThrowException::createTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("promiseCheckOverload", "Internals", "parameter 1 is not of type 'Location'."))));
            return;
        }
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->promiseCheckOverload(scriptState, arg1);
    v8SetReturnValue(info, result.v8Value());
}

static void promiseCheckOverload2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* arg1;
    {
        arg1 = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!arg1) {
            v8SetReturnValue(info, ScriptPromise::rejectRaw(ScriptState::current(info.GetIsolate()), V8ThrowException::createTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("promiseCheckOverload", "Internals", "parameter 1 is not of type 'Document'."))));
            return;
        }
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->promiseCheckOverload(scriptState, arg1);
    v8SetReturnValue(info, result.v8Value());
}

static void promiseCheckOverload3MethodPromise(const v8::FunctionCallbackInfo<v8::Value>& info, ExceptionState& exceptionState)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    Location* arg1;
    int arg2;
    int arg3;
    {
        arg1 = V8Location::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!arg1) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Location'.");
            return;
        }
        arg2 = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;
        arg3 = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.hadException())
            return;
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    ScriptPromise result = impl->promiseCheckOverload(scriptState, arg1, arg2, arg3);
    v8SetReturnValue(info, result.v8Value());
}

static void promiseCheckOverload3Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "promiseCheckOverload", "Internals", info.Holder(), info.GetIsolate());
    promiseCheckOverload3MethodPromise(info, exceptionState);
    if (exceptionState.hadException())
        v8SetReturnValue(info, exceptionState.reject(ScriptState::current(info.GetIsolate())).v8Value());
}

static void promiseCheckOverloadMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "promiseCheckOverload", "Internals", info.Holder(), info.GetIsolate());
    switch (std::min(3, info.Length())) {
    case 1:
        if (V8Location::hasInstance(info[0], info.GetIsolate())) {
            promiseCheckOverload1Method(info);
            return;
        }
        if (V8Document::hasInstance(info[0], info.GetIsolate())) {
            promiseCheckOverload2Method(info);
            return;
        }
        break;
    case 3:
        if (true) {
            promiseCheckOverload3Method(info);
            return;
        }
        break;
    default:
        if (info.Length() >= 1) {
            setArityTypeError(exceptionState, "[1, 3]", info.Length());
            v8SetReturnValue(info, exceptionState.reject(ScriptState::current(info.GetIsolate())).v8Value());
            return;
        }
        break;
    }
    if (info.Length() < 1) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
        v8SetReturnValue(info, exceptionState.reject(ScriptState::current(info.GetIsolate())).v8Value());
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    v8SetReturnValue(info, exceptionState.reject(ScriptState::current(info.GetIsolate())).v8Value());
    return;
}

static void promiseCheckOverloadMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::promiseCheckOverloadMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setValueForUserMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "setValueForUser", "Internals", 2, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    V8StringResource<> value;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("setValueForUser", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
        value = info[1];
        if (!value.prepare())
            return;
    }
    impl->setValueForUser(element, value);
}

static void setValueForUserMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setValueForUserMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void textSurroundingNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "textSurroundingNode", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 4)) {
        setMinimumArityTypeError(exceptionState, 4, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Node* node;
    int x;
    int y;
    unsigned maxLength;
    {
        node = V8Node::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!node) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Node'.");
            exceptionState.throwIfNeeded();
            return;
        }
        x = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toInt32(info.GetIsolate(), info[2], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        maxLength = toUInt32(info.GetIsolate(), info[3], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueString(info, impl->textSurroundingNode(node, x, y, maxLength), info.GetIsolate());
}

static void textSurroundingNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::textSurroundingNodeMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setFocusedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setFocused", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    bool focused;
    {
        focused = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setFocused(focused);
}

static void setFocusedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setFocusedMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setInitialFocusMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setInitialFocus", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    bool reverse;
    {
        reverse = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setInitialFocus(reverse);
}

static void setInitialFocusMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setInitialFocusMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void ignoreLayoutWithPendingStylesheetsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "ignoreLayoutWithPendingStylesheets", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("ignoreLayoutWithPendingStylesheets", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
    }
    v8SetReturnValueBool(info, impl->ignoreLayoutWithPendingStylesheets(document));
}

static void ignoreLayoutWithPendingStylesheetsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::ignoreLayoutWithPendingStylesheetsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setNetworkStateNotifierTestOnlyMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setNetworkStateNotifierTestOnly", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    bool testOnly;
    {
        testOnly = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setNetworkStateNotifierTestOnly(testOnly);
}

static void setNetworkStateNotifierTestOnlyMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setNetworkStateNotifierTestOnlyMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setNetworkConnectionInfoMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setNetworkConnectionInfo", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    V8StringResource<> type;
    {
        type = info[0];
        if (!type.prepare())
            return;
    }
    impl->setNetworkConnectionInfo(type, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setNetworkConnectionInfoMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setNetworkConnectionInfoMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void countHitRegionsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "countHitRegions", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    CanvasRenderingContext2D* context;
    {
        context = V8CanvasRenderingContext2D::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!context) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("countHitRegions", "Internals", "parameter 1 is not of type 'CanvasRenderingContext2D'."));
            return;
        }
    }
    v8SetReturnValueUnsigned(info, impl->countHitRegions(context));
}

static void countHitRegionsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::countHitRegionsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isInCanvasFontCacheMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "isInCanvasFontCache", "Internals", 2, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    V8StringResource<> fontString;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("isInCanvasFontCache", "Internals", "parameter 1 is not of type 'Document'."));
            return;
        }
        fontString = info[1];
        if (!fontString.prepare())
            return;
    }
    v8SetReturnValueBool(info, impl->isInCanvasFontCache(document, fontString));
}

static void isInCanvasFontCacheMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::isInCanvasFontCacheMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void canvasFontCacheMaxFontsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValueUnsigned(info, impl->canvasFontCacheMaxFonts());
}

static void canvasFontCacheMaxFontsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::canvasFontCacheMaxFontsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void boundsInViewportSpaceMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "boundsInViewportSpace", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("boundsInViewportSpace", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->boundsInViewportSpace(element));
}

static void boundsInViewportSpaceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::boundsInViewportSpaceMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void forcePluginPlaceholder1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "forcePluginPlaceholder", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    HTMLElement* plugin;
    DocumentFragment* fragment;
    {
        plugin = V8HTMLElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!plugin) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        fragment = V8DocumentFragment::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!fragment) {
            exceptionState.throwTypeError("parameter 2 is not of type 'DocumentFragment'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->forcePluginPlaceholder(plugin, fragment, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void forcePluginPlaceholder2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "forcePluginPlaceholder", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    HTMLElement* plugin;
    PluginPlaceholderOptions options;
    {
        plugin = V8HTMLElement::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!plugin) {
            exceptionState.throwTypeError("parameter 1 is not of type 'HTMLElement'.");
            exceptionState.throwIfNeeded();
            return;
        }
        if (!isUndefinedOrNull(info[1]) && !info[1]->IsObject()) {
            exceptionState.throwTypeError("parameter 2 ('options') is not an object.");
            exceptionState.throwIfNeeded();
            return;
        }
        V8PluginPlaceholderOptions::toImpl(info.GetIsolate(), info[1], options, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->forcePluginPlaceholder(plugin, options, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void forcePluginPlaceholderMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "forcePluginPlaceholder", "Internals", info.Holder(), info.GetIsolate());
    switch (std::min(2, info.Length())) {
    case 2:
        if (V8DocumentFragment::hasInstance(info[1], info.GetIsolate())) {
            forcePluginPlaceholder1Method(info);
            return;
        }
        if (info[1]->IsObject()) {
            forcePluginPlaceholder2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    if (info.Length() < 2) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void forcePluginPlaceholderMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::forcePluginPlaceholderMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void dictionaryTestMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValue(info, impl->dictionaryTest());
}

static void dictionaryTestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::dictionaryTestMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void unionTypesTestMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValue(info, impl->unionTypesTest());
}

static void unionTypesTestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::unionTypesTestMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void forceBlinkGCWithoutV8GCMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    impl->forceBlinkGCWithoutV8GC();
}

static void forceBlinkGCWithoutV8GCMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::forceBlinkGCWithoutV8GCMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void selectedHTMLForClipboardMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValueString(info, impl->selectedHTMLForClipboard(), info.GetIsolate());
}

static void selectedHTMLForClipboardMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::selectedHTMLForClipboardMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void selectedTextForClipboardMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValueString(info, impl->selectedTextForClipboard(), info.GetIsolate());
}

static void selectedTextForClipboardMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::selectedTextForClipboardMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setVisualViewportOffsetMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setVisualViewportOffset", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    int x;
    int y;
    {
        x = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setVisualViewportOffset(x, y);
}

static void setVisualViewportOffsetMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setVisualViewportOffsetMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void isUseCountedMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "isUseCounted", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Document* document;
    int useCounterId;
    {
        document = V8Document::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!document) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Document'.");
            exceptionState.throwIfNeeded();
            return;
        }
        useCounterId = toInt32(info.GetIsolate(), info[1], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueBool(info, impl->isUseCounted(document, useCounterId));
}

static void isUseCountedMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::isUseCountedMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void unscopeableMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Internals* impl = V8Internals::toImpl(info.Holder());
    v8SetReturnValueString(info, impl->unscopeableMethod(), info.GetIsolate());
}

static void unscopeableMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::unscopeableMethodMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void focusRingRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), "focusRingRects", "Internals", 1, info.Length()), info.GetIsolate());
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    Element* element;
    {
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!element) {
            V8ThrowException::throwTypeError(info.GetIsolate(), ExceptionMessages::failedToExecute("focusRingRects", "Internals", "parameter 1 is not of type 'Element'."));
            return;
        }
    }
    v8SetReturnValue(info, impl->focusRingRects(element));
}

static void focusRingRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::focusRingRectsMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void setCapsLockStateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setCapsLockState", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    bool enabled;
    {
        enabled = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setCapsLockState(enabled);
}

static void setCapsLockStateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::setCapsLockStateMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void keysMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "keys", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    RawPtr<Iterator> result = impl->keysForBinding(scriptState, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void keysMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::keysMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void valuesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "values", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    RawPtr<Iterator> result = impl->valuesForBinding(scriptState, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void valuesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::valuesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void entriesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "entries", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    RawPtr<Iterator> result = impl->entriesForBinding(scriptState, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void entriesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::entriesMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void forEachMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "forEach", "Internals", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Internals* impl = V8Internals::toImpl(info.Holder());
    ScriptValue callback;
    ScriptValue thisArg;
    {
        if (!info[0]->IsFunction()) {
            exceptionState.throwTypeError("The callback provided as parameter 1 is not a function.");
            exceptionState.throwIfNeeded();
            return;
        }
        callback = ScriptValue(ScriptState::current(info.GetIsolate()), info[0]);
        thisArg = ScriptValue(ScriptState::current(info.GetIsolate()), info[1]);
    }
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    impl->forEachForBinding(scriptState, ScriptValue(scriptState, info.This()), callback, thisArg, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void forEachMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::forEachMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

static void iteratorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "iterator", "Internals", info.Holder(), info.GetIsolate());
    Internals* impl = V8Internals::toImpl(info.Holder());
    ScriptState* scriptState = ScriptState::current(info.GetIsolate());
    RawPtr<Iterator> result = impl->iterator(scriptState, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValue(info, result.release());
}

static void iteratorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE("blink", "DOMMethod");
    InternalsV8Internal::iteratorMethod(info);
    TRACE_EVENT_SET_SAMPLING_STATE("v8", "V8Execution");
}

} // namespace InternalsV8Internal

static const V8DOMConfiguration::AccessorConfiguration V8InternalsAccessors[] = {
    {"pagePopupWindow", InternalsV8Internal::pagePopupWindowAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"settings", InternalsV8Internal::settingsAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"runtimeFlags", InternalsV8Internal::runtimeFlagsAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"workerThreadCount", InternalsV8Internal::workerThreadCountAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"cursorUpdatePending", InternalsV8Internal::cursorUpdatePendingAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"unscopeableAttribute", InternalsV8Internal::unscopeableAttributeAttributeGetterCallback, 0, 0, 0, 0, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
};

static const V8DOMConfiguration::MethodConfiguration V8InternalsMethods[] = {
    {"address", InternalsV8Internal::addressMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"observeGC", InternalsV8Internal::observeGCMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"elementLayoutTreeAsText", InternalsV8Internal::elementLayoutTreeAsTextMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"isPreloaded", InternalsV8Internal::isPreloadedMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"isPreloadedBy", InternalsV8Internal::isPreloadedByMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"isLoadingFromMemoryCache", InternalsV8Internal::isLoadingFromMemoryCacheMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"isSharingStyle", InternalsV8Internal::isSharingStyleMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"computedStyleIncludingVisitedInfo", InternalsV8Internal::computedStyleIncludingVisitedInfoMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"createUserAgentShadowRoot", InternalsV8Internal::createUserAgentShadowRootMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"shadowRoot", InternalsV8Internal::shadowRootMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"youngestShadowRoot", InternalsV8Internal::youngestShadowRootMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"oldestShadowRoot", InternalsV8Internal::oldestShadowRootMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"youngerShadowRoot", InternalsV8Internal::youngerShadowRootMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"shadowRootType", InternalsV8Internal::shadowRootTypeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"hasShadowInsertionPoint", InternalsV8Internal::hasShadowInsertionPointMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"hasContentElement", InternalsV8Internal::hasContentElementMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"countElementShadow", InternalsV8Internal::countElementShadowMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"shadowPseudoId", InternalsV8Internal::shadowPseudoIdMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"isValidContentSelect", InternalsV8Internal::isValidContentSelectMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"treeScopeRootNode", InternalsV8Internal::treeScopeRootNodeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"parentTreeScope", InternalsV8Internal::parentTreeScopeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"hasSelectorForIdInShadow", InternalsV8Internal::hasSelectorForIdInShadowMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"hasSelectorForClassInShadow", InternalsV8Internal::hasSelectorForClassInShadowMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"hasSelectorForAttributeInShadow", InternalsV8Internal::hasSelectorForAttributeInShadowMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"compareTreeScopePosition", InternalsV8Internal::compareTreeScopePositionMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"updateStyleAndReturnAffectedElementCount", InternalsV8Internal::updateStyleAndReturnAffectedElementCountMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"needsLayoutCount", InternalsV8Internal::needsLayoutCountMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"hitTestCount", InternalsV8Internal::hitTestCountMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"hitTestCacheHits", InternalsV8Internal::hitTestCacheHitsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"elementFromPoint", InternalsV8Internal::elementFromPointMethodCallback, 0, 5, V8DOMConfiguration::ExposedToAllScripts},
    {"clearHitTestCache", InternalsV8Internal::clearHitTestCacheMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"pauseAnimations", InternalsV8Internal::pauseAnimationsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"isCompositedAnimation", InternalsV8Internal::isCompositedAnimationMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"advanceTimeForImage", InternalsV8Internal::advanceTimeForImageMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"nextSiblingInComposedTree", InternalsV8Internal::nextSiblingInComposedTreeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"firstChildInComposedTree", InternalsV8Internal::firstChildInComposedTreeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"lastChildInComposedTree", InternalsV8Internal::lastChildInComposedTreeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"nextInComposedTree", InternalsV8Internal::nextInComposedTreeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"previousInComposedTree", InternalsV8Internal::previousInComposedTreeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"visiblePlaceholder", InternalsV8Internal::visiblePlaceholderMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"selectColorInColorChooser", InternalsV8Internal::selectColorInColorChooserMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"endColorChooser", InternalsV8Internal::endColorChooserMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"hasAutofocusRequest", InternalsV8Internal::hasAutofocusRequestMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"formControlStateOfHistoryItem", InternalsV8Internal::formControlStateOfHistoryItemMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"setFormControlStateOfHistoryItem", InternalsV8Internal::setFormControlStateOfHistoryItemMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"absoluteCaretBounds", InternalsV8Internal::absoluteCaretBoundsMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"boundingBox", InternalsV8Internal::boundingBoxMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"markerCountForNode", InternalsV8Internal::markerCountForNodeMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"activeMarkerCountForNode", InternalsV8Internal::activeMarkerCountForNodeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"markerRangeForNode", InternalsV8Internal::markerRangeForNodeMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"markerDescriptionForNode", InternalsV8Internal::markerDescriptionForNodeMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"addTextMatchMarker", InternalsV8Internal::addTextMatchMarkerMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"setMarkersActive", InternalsV8Internal::setMarkersActiveMethodCallback, 0, 4, V8DOMConfiguration::ExposedToAllScripts},
    {"setMarkedTextMatchesAreHighlighted", InternalsV8Internal::setMarkedTextMatchesAreHighlightedMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"setFrameViewPosition", InternalsV8Internal::setFrameViewPositionMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"viewportAsText", InternalsV8Internal::viewportAsTextMethodCallback, 0, 4, V8DOMConfiguration::ExposedToAllScripts},
    {"wasLastChangeUserEdit", InternalsV8Internal::wasLastChangeUserEditMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"elementShouldAutoComplete", InternalsV8Internal::elementShouldAutoCompleteMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"suggestedValue", InternalsV8Internal::suggestedValueMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"setSuggestedValue", InternalsV8Internal::setSuggestedValueMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"setEditingValue", InternalsV8Internal::setEditingValueMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"setAutofilled", InternalsV8Internal::setAutofilledMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"scrollElementToRect", InternalsV8Internal::scrollElementToRectMethodCallback, 0, 5, V8DOMConfiguration::ExposedToAllScripts},
    {"rangeFromLocationAndLength", InternalsV8Internal::rangeFromLocationAndLengthMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"locationFromRange", InternalsV8Internal::locationFromRangeMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"lengthFromRange", InternalsV8Internal::lengthFromRangeMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"rangeAsText", InternalsV8Internal::rangeAsTextMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"touchPositionAdjustedToBestClickableNode", InternalsV8Internal::touchPositionAdjustedToBestClickableNodeMethodCallback, 0, 5, V8DOMConfiguration::ExposedToAllScripts},
    {"touchNodeAdjustedToBestClickableNode", InternalsV8Internal::touchNodeAdjustedToBestClickableNodeMethodCallback, 0, 5, V8DOMConfiguration::ExposedToAllScripts},
    {"touchPositionAdjustedToBestContextMenuNode", InternalsV8Internal::touchPositionAdjustedToBestContextMenuNodeMethodCallback, 0, 5, V8DOMConfiguration::ExposedToAllScripts},
    {"touchNodeAdjustedToBestContextMenuNode", InternalsV8Internal::touchNodeAdjustedToBestContextMenuNodeMethodCallback, 0, 5, V8DOMConfiguration::ExposedToAllScripts},
    {"bestZoomableAreaForTouchPoint", InternalsV8Internal::bestZoomableAreaForTouchPointMethodCallback, 0, 5, V8DOMConfiguration::ExposedToAllScripts},
    {"lastSpellCheckRequestSequence", InternalsV8Internal::lastSpellCheckRequestSequenceMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"lastSpellCheckProcessedSequence", InternalsV8Internal::lastSpellCheckProcessedSequenceMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"userPreferredLanguages", InternalsV8Internal::userPreferredLanguagesMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"setUserPreferredLanguages", InternalsV8Internal::setUserPreferredLanguagesMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"activeDOMObjectCount", InternalsV8Internal::activeDOMObjectCountMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"wheelEventHandlerCount", InternalsV8Internal::wheelEventHandlerCountMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"scrollEventHandlerCount", InternalsV8Internal::scrollEventHandlerCountMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"touchEventHandlerCount", InternalsV8Internal::touchEventHandlerCountMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"touchEventTargetLayerRects", InternalsV8Internal::touchEventTargetLayerRectsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"executeCommand", InternalsV8Internal::executeCommandMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"htmlNamespace", InternalsV8Internal::htmlNamespaceMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"htmlTags", InternalsV8Internal::htmlTagsMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"svgNamespace", InternalsV8Internal::svgNamespaceMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"svgTags", InternalsV8Internal::svgTagsMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"nodesFromRect", InternalsV8Internal::nodesFromRectMethodCallback, 0, 9, V8DOMConfiguration::ExposedToAllScripts},
    {"hasSpellingMarker", InternalsV8Internal::hasSpellingMarkerMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"hasGrammarMarker", InternalsV8Internal::hasGrammarMarkerMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"setContinuousSpellCheckingEnabled", InternalsV8Internal::setContinuousSpellCheckingEnabledMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"isOverwriteModeEnabled", InternalsV8Internal::isOverwriteModeEnabledMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"toggleOverwriteModeEnabled", InternalsV8Internal::toggleOverwriteModeEnabledMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"numberOfScrollableAreas", InternalsV8Internal::numberOfScrollableAreasMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"isPageBoxVisible", InternalsV8Internal::isPageBoxVisibleMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"layerTreeAsText", InternalsV8Internal::layerTreeAsTextMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"elementLayerTreeAsText", InternalsV8Internal::elementLayerTreeAsTextMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"scrollsWithRespectTo", InternalsV8Internal::scrollsWithRespectToMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"scrollingStateTreeAsText", InternalsV8Internal::scrollingStateTreeAsTextMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"mainThreadScrollingReasons", InternalsV8Internal::mainThreadScrollingReasonsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"nonFastScrollableRects", InternalsV8Internal::nonFastScrollableRectsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"garbageCollectDocumentResources", InternalsV8Internal::garbageCollectDocumentResourcesMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"evictAllResources", InternalsV8Internal::evictAllResourcesMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"numberOfLiveNodes", InternalsV8Internal::numberOfLiveNodesMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"numberOfLiveDocuments", InternalsV8Internal::numberOfLiveDocumentsMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"dumpRefCountedInstanceCounts", InternalsV8Internal::dumpRefCountedInstanceCountsMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"consoleMessageArgumentCounts", InternalsV8Internal::consoleMessageArgumentCountsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"setMemoryCacheCapacities", InternalsV8Internal::setMemoryCacheCapacitiesMethodCallback, 0, 3, V8DOMConfiguration::ExposedToAllScripts},
    {"counterValue", InternalsV8Internal::counterValueMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"pageNumber", InternalsV8Internal::pageNumberMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"shortcutIconURLs", InternalsV8Internal::shortcutIconURLsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"allIconURLs", InternalsV8Internal::allIconURLsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"numberOfPages", InternalsV8Internal::numberOfPagesMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"pageProperty", InternalsV8Internal::pagePropertyMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"pageSizeAndMarginsInPixels", InternalsV8Internal::pageSizeAndMarginsInPixelsMethodCallback, 0, 7, V8DOMConfiguration::ExposedToAllScripts},
    {"setDeviceScaleFactor", InternalsV8Internal::setDeviceScaleFactorMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"setPageScaleFactor", InternalsV8Internal::setPageScaleFactorMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"setPageScaleFactorLimits", InternalsV8Internal::setPageScaleFactorLimitsMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"setIsCursorVisible", InternalsV8Internal::setIsCursorVisibleMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"effectiveMediaVolume", InternalsV8Internal::effectiveMediaVolumeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"mediaPlayerRemoteRouteAvailabilityChanged", InternalsV8Internal::mediaPlayerRemoteRouteAvailabilityChangedMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"mediaPlayerPlayingRemotelyChanged", InternalsV8Internal::mediaPlayerPlayingRemotelyChangedMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"registerURLSchemeAsBypassingContentSecurityPolicy", InternalsV8Internal::registerURLSchemeAsBypassingContentSecurityPolicyMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"removeURLSchemeRegisteredAsBypassingContentSecurityPolicy", InternalsV8Internal::removeURLSchemeRegisteredAsBypassingContentSecurityPolicyMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"typeConversions", InternalsV8Internal::typeConversionsMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"privateScriptTest", InternalsV8Internal::privateScriptTestMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"getReferencedFilePaths", InternalsV8Internal::getReferencedFilePathsMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"startTrackingRepaints", InternalsV8Internal::startTrackingRepaintsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"stopTrackingRepaints", InternalsV8Internal::stopTrackingRepaintsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks", InternalsV8Internal::updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"forceFullRepaint", InternalsV8Internal::forceFullRepaintMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"draggableRegions", InternalsV8Internal::draggableRegionsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"nonDraggableRegions", InternalsV8Internal::nonDraggableRegionsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"getCurrentCursorInfo", InternalsV8Internal::getCurrentCursorInfoMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"markerTextForListItem", InternalsV8Internal::markerTextForListItemMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"deserializeBuffer", InternalsV8Internal::deserializeBufferMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"serializeObject", InternalsV8Internal::serializeObjectMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"forceReload", InternalsV8Internal::forceReloadMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"getImageSourceURL", InternalsV8Internal::getImageSourceURLMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"selectMenuListText", InternalsV8Internal::selectMenuListTextMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"isSelectPopupVisible", InternalsV8Internal::isSelectPopupVisibleMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"selectPopupItemStyleIsRtl", InternalsV8Internal::selectPopupItemStyleIsRtlMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"selectPopupItemStyleFontHeight", InternalsV8Internal::selectPopupItemStyleFontHeightMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"selectionBounds", InternalsV8Internal::selectionBoundsMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"loseSharedGraphicsContext3D", InternalsV8Internal::loseSharedGraphicsContext3DMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"forceCompositingUpdate", InternalsV8Internal::forceCompositingUpdateMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"setZoomFactor", InternalsV8Internal::setZoomFactorMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"setShouldRevealPassword", InternalsV8Internal::setShouldRevealPasswordMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"createResolvedPromise", InternalsV8Internal::createResolvedPromiseMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"createRejectedPromise", InternalsV8Internal::createRejectedPromiseMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"addOneToPromise", InternalsV8Internal::addOneToPromiseMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"promiseCheck", InternalsV8Internal::promiseCheckMethodCallback, 0, 5, V8DOMConfiguration::ExposedToAllScripts},
    {"promiseCheckWithoutExceptionState", InternalsV8Internal::promiseCheckWithoutExceptionStateMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"promiseCheckRange", InternalsV8Internal::promiseCheckRangeMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"promiseCheckOverload", InternalsV8Internal::promiseCheckOverloadMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"setValueForUser", InternalsV8Internal::setValueForUserMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"textSurroundingNode", InternalsV8Internal::textSurroundingNodeMethodCallback, 0, 4, V8DOMConfiguration::ExposedToAllScripts},
    {"setFocused", InternalsV8Internal::setFocusedMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"setInitialFocus", InternalsV8Internal::setInitialFocusMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"ignoreLayoutWithPendingStylesheets", InternalsV8Internal::ignoreLayoutWithPendingStylesheetsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"setNetworkStateNotifierTestOnly", InternalsV8Internal::setNetworkStateNotifierTestOnlyMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"setNetworkConnectionInfo", InternalsV8Internal::setNetworkConnectionInfoMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"countHitRegions", InternalsV8Internal::countHitRegionsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"isInCanvasFontCache", InternalsV8Internal::isInCanvasFontCacheMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"canvasFontCacheMaxFonts", InternalsV8Internal::canvasFontCacheMaxFontsMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"boundsInViewportSpace", InternalsV8Internal::boundsInViewportSpaceMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"forcePluginPlaceholder", InternalsV8Internal::forcePluginPlaceholderMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"dictionaryTest", InternalsV8Internal::dictionaryTestMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"unionTypesTest", InternalsV8Internal::unionTypesTestMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"forceBlinkGCWithoutV8GC", InternalsV8Internal::forceBlinkGCWithoutV8GCMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"selectedHTMLForClipboard", InternalsV8Internal::selectedHTMLForClipboardMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"selectedTextForClipboard", InternalsV8Internal::selectedTextForClipboardMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"setVisualViewportOffset", InternalsV8Internal::setVisualViewportOffsetMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"isUseCounted", InternalsV8Internal::isUseCountedMethodCallback, 0, 2, V8DOMConfiguration::ExposedToAllScripts},
    {"unscopeableMethod", InternalsV8Internal::unscopeableMethodMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"focusRingRects", InternalsV8Internal::focusRingRectsMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"setCapsLockState", InternalsV8Internal::setCapsLockStateMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
    {"keys", InternalsV8Internal::keysMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"values", InternalsV8Internal::valuesMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"entries", InternalsV8Internal::entriesMethodCallback, 0, 0, V8DOMConfiguration::ExposedToAllScripts},
    {"forEach", InternalsV8Internal::forEachMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},
};

void V8Internals::installV8InternalsTemplate(v8::Local<v8::FunctionTemplate> functionTemplate, v8::Isolate* isolate)
{
    functionTemplate->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = V8DOMConfiguration::installDOMClassTemplate(isolate, functionTemplate, "Internals", v8::Local<v8::FunctionTemplate>(), V8Internals::internalFieldCount,
        0, 0,
        V8InternalsAccessors, WTF_ARRAY_LENGTH(V8InternalsAccessors),
        V8InternalsMethods, WTF_ARRAY_LENGTH(V8InternalsMethods));
    v8::Local<v8::ObjectTemplate> instanceTemplate = functionTemplate->InstanceTemplate();
    ALLOW_UNUSED_LOCAL(instanceTemplate);
    v8::Local<v8::ObjectTemplate> prototypeTemplate = functionTemplate->PrototypeTemplate();
    ALLOW_UNUSED_LOCAL(prototypeTemplate);
    static const V8DOMConfiguration::ConstantConfiguration V8InternalsConstants[] = {
        {"LAYER_TREE_INCLUDES_REPAINT_RECTS", 2, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"LAYER_TREE_INCLUDES_PAINTING_PHASES", 4, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"LAYER_TREE_INCLUDES_ROOT_LAYER", 8, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"LAYER_TREE_INCLUDES_CLIP_AND_SCROLL_PARENTS", 16, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"LAYER_TREE_INCLUDES_SCROLL_BLOCKS_ON", 32, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"LAYER_TREE_INCLUDES_PAINT_INVALIDATION_OBJECTS", 64, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
        {"LAYER_TREE_INCLUDES_COMPOSITING_REASONS", 128, 0, 0, V8DOMConfiguration::ConstantTypeUnsignedShort},
    };
    V8DOMConfiguration::installConstants(isolate, functionTemplate, prototypeTemplate, V8InternalsConstants, WTF_ARRAY_LENGTH(V8InternalsConstants));
    static const V8DOMConfiguration::SymbolKeyedMethodConfiguration symbolKeyedIteratorConfiguration = { v8::Symbol::GetIterator, InternalsV8Internal::iteratorMethodCallback, 0, V8DOMConfiguration::ExposedToAllScripts };
    V8DOMConfiguration::installMethod(isolate, prototypeTemplate, defaultSignature, v8::DontDelete, symbolKeyedIteratorConfiguration);

    // Custom toString template
    functionTemplate->Set(v8AtomicString(isolate, "toString"), V8PerIsolateData::from(isolate)->toStringTemplate());
}

v8::Local<v8::FunctionTemplate> V8Internals::domTemplate(v8::Isolate* isolate)
{
    ASSERT(V8Internals::installV8InternalsTemplateFunction != V8Internals::installV8InternalsTemplate);
    return V8DOMConfiguration::domClassTemplate(isolate, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), V8Internals::installV8InternalsTemplateFunction);
}

bool V8Internals::hasInstance(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Local<v8::Object> V8Internals::findInstanceInPrototypeChain(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

Internals* V8Internals::toImplWithTypeCheck(v8::Isolate* isolate, v8::Local<v8::Value> value)
{
    return hasInstance(value, isolate) ? toImpl(v8::Local<v8::Object>::Cast(value)) : 0;
}

void V8Internals::preparePrototypeObject(v8::Isolate* isolate, v8::Local<v8::Object> prototypeObject, v8::Local<v8::FunctionTemplate> interfaceTemplate)
{
    v8::Local<v8::Context> v8Context(prototypeObject->CreationContext());
    v8::Local<v8::Name> unscopablesSymbol(v8::Symbol::GetUnscopables(isolate));
    v8::Local<v8::Object> unscopeables;
    if (v8CallBoolean(prototypeObject->HasOwnProperty(v8Context, unscopablesSymbol)))
        unscopeables = prototypeObject->Get(v8Context, unscopablesSymbol).ToLocalChecked().As<v8::Object>();
    else
        unscopeables = v8::Object::New(isolate);
    unscopeables->CreateDataProperty(v8Context, v8AtomicString(isolate, "unscopeableAttribute"), v8::True(isolate)).FromJust();
    unscopeables->CreateDataProperty(v8Context, v8AtomicString(isolate, "unscopeableMethod"), v8::True(isolate)).FromJust();
    prototypeObject->CreateDataProperty(v8Context, unscopablesSymbol, unscopeables).FromJust();
}

void V8Internals::refObject(ScriptWrappable* scriptWrappable)
{
}

void V8Internals::derefObject(ScriptWrappable* scriptWrappable)
{
}

InstallTemplateFunction V8Internals::installV8InternalsTemplateFunction = (InstallTemplateFunction)&V8Internals::installV8InternalsTemplate;

void V8Internals::updateWrapperTypeInfo(InstallTemplateFunction installTemplateFunction, PreparePrototypeObjectFunction preparePrototypeObjectFunction)
{
    V8Internals::installV8InternalsTemplateFunction = installTemplateFunction;
    if (preparePrototypeObjectFunction)
        V8Internals::wrapperTypeInfo.preparePrototypeObjectFunction = preparePrototypeObjectFunction;
}

v8::Local<v8::Object> blink::v8IteratorResultValue(v8::Isolate *, bool, v8::Local<v8::Value>)
{
#ifdef IMPLEMENTED_NEWEST_BLINK
#endif // IMPLEMENTED_NEWEST_BLINK
	notImplemented();
	return v8::Local<v8::Object>();
}

} // namespace blink
